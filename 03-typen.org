#+TITLE: Programmiersprachen und Übersetzer
#+SUBTITLE: 03 - Typen
#+SETUPFILE: setup.org
#+INCLUDE: export-prologue.org
#+PROPERTY: header-args:latex :tangle yes :noweb yes :tangle-macros yes :tangle-prologue topic :tangle-epilogue endtopic :exports none

#+NAME: topic
#+BEGIN_SRC latex :tangle no
\psuSectionStart{{{{property(ITEM)}}}}{{{{n(block)}}}}
#+END_SRC

#+NAME: endtopic
#+BEGIN_SRC latex :tangle no
\psuSectionStop{{{{property(ITEM)}}}}{{{{n(block,-)}}}}
#+END_SRC

* Gedanken zu dieser Vorlesung                                     :noexport:

Was lernt man aus dieser Vorlesung für die Ziele effektiv und effizient?
 - Typen sind immer da. Schreibt man sie auf, werden sie Freunde. [effektiv]
 - Typen sind _die_ Informationsquelle für den Übersetzer.        [effizient]


* Was ist ein "Typ"?
:PROPERTIES:
:CUSTOM_ID: 03-einleitung
:END:

#+begin_src latex
  \subtitle{{{{subtitle()}}}}
  \begin{frame}
    \maketitle
  \end{frame}

  \begin{frame}{Wieso sollte ich mich mit Typen beschäftigen?}
    \begin{center}
      \includegraphics[page=10,width=0.6\linewidth]{fig/01-overview-small}
    \end{center}
    \bi
    \ii Typen sind das Rückgrat moderner Programmiersprachen. {
      \bi
      \ii Je mehr das Typsystem abfängt, desto weniger muss man denken.
      \ii Das Typsystem ist eine wichtige Quelle für automatische Optimierungen.
      \ei
    }
    \ei
  \end{frame}

  \begin{frame}<handout:1-2>[fragile]{Was bieten einem Typen?}
    \bi
    \ii Typen bieten \textbf{Kontext} und transportieren Informationen quer zum AST.{
      \bi
      \ii Ohne Typen:  Wir müssten die Operation immer ganz genau angeben.\\
          {
            \hfill\codeinline{var a,b; ... float32_add(a, b)}
            \hfill\codeinline[style=C,morekeywords={int32_t}]{int32_t a, b; .... a+b}
            \hfill\mbox{}
          }
          \ii Mit Typen: Der Übersetzer wählt die passende Operation entsprechend.
      \ei
    }\bigskip
    \ii Typen \textbf{schützen vor Bugs} und verhindern invalide Aktionen. {
      \bi
      \ii \codeinline{Cat k1; ... k1 = Dog();} $\Rightarrow$ \enquote{Type mismatch: Cannot assign 'Dog' to 'Cat'}\\[0.5ex]
      \ii Mit Typen macht ein Programmierer Zusicherungen über eine Objekt.
      \ei
    }
    \bigskip
    \ii Typen \textbf{verbessern die Lesbarkeit} von Code und sind Dokumentation. {
      \bi
      \ii Mit statisch Typen kommunizieren wir Intention und angedachte Verwendung.
      \ii Eine gute API ist bereits anhand der Typnamen verständlich:{\\[1ex]
        \begin{center}
          \codeinline<1|handout:1>[style=C]{____ regex_match(________, ___________, _____________)}%
          \codeinline<2-|handout:2>[style=C,morekeywords={bool,regex_t,regex_flags_t}]{bool regex_match(regex_t*, const char*, regex_flags_t)}
        \end{center}
      }
      \ei
    }
    \ei
    \onslide<3-|handout:2>{
      \medskip
      \Large \alert{$\Rightarrow$ Typen sind Freunde und Helfer in der Not!}
    }
  \end{frame}

  #+end_src

Diese Vorlesung ist der erste Teil unserer Top-Down Betrachtung von Programmiersprachen.
Dabei wollen wir uns insgesamt 4 Themen herausgreifen (Typen, Namen, Operationen und Objekte), die in der einen oder anderen Form in jeder Programmiersprache vorkommen.
In Zuge dieser Betrachtungen sollen Sie lernen, dass es grundlegende Prinzipien in Programmiersprachen gibt, die immer wieder, in unterschiedlichen Kombinationen und Geschmacksrichtungen, auftreten.
Der Ingeneur baut eben doch immer das was er kennt, bzw.
er verlässt sich auf bewährte Konzepte, die häufig durch einen reichen Korpus an theoretischen Überlegungen fußen.

In dieser Vorlesung wollen wir uns mit dem Aspekt der Typen in Programmiersprachen beschäftigen.
Dabei wollen wir uns zunächst überlegen, was Typen, ganz [[https://de.wikipedia.org/wiki/Essentialismus][essentialistisch]], sind und was die einfachsten Ausprägungen des Konzepts "Typen" sind.
Dies beinhaltet, zum Beispiel, die Ganzzahl- und Zeigertypen, aber auch Record und Array Typen.
Darauf aufbauend, werden wir uns dem Bereich der *Polymorphie* zuwenden, der ganz essentiell für unsere modernen Programmiersprachen ist.
Mit diesen polymorphen Typen können wir uns ein, potentiell unendliches, Universum von Typkombinationen definieren, das dabei hilft unsere Programme sauber zu strukturieren und uns vor uns selbst und unseren Bugs schützt.
Am Ende dieser Vorlesungseinheit werden wir uns anschauen, wie die Typen, die wir in den vorherigen Kapiteln konstruiert haben, in Programmiersprachen zu einem *Typsystem*  kombiniert werden.

Diese Vorlesung über Typen ist deswegen so spannend, weil moderne Programmiersprachen, wie C++ oder Rust, sehr ausgefeilte Typsstyeme besitzen, die gewissermaßen das Rückrat dieser Sprachen bilden. Nur mit Hilfe dieser rigurosen Typssysteme, die vom Übersetzer vor der Laufzeit durchgesetzt werden, ist es möglich große Programme mit vielen Entwicklern gleichzeit zu entwerfen. Typen sind dabei ein Kommunikationsmittel zwischen einem einzelnen Entwickler und der Maschine, und zwischen Entwicklern. In beiden Fällen verwendet der Programmierer die Typannotationen um zu Kommunizieren: "Beim Anlegen dieser Variable habe ich mir gedacht, dass folgende Eigenschaften und Invarianten gelten sollten".

Wenn der Entwickler mit dem Übersetzer kommuniziert, sind zwei Aspekte von Typen im Vordergrund: Der querschneidende Informationsfluss und das explizit machen von Erwartungen.

Im Kapitel über Parsing haben wir gelernt, dass wir die Syntax unserer Maschinenprogramme kontextfrei extrahieren und als Baum darstellen können.
Der große Nachteil von Bäumen ist allerdings, dass sie streng hierarchisch sind.
Folgt man also nur den Kanten eines Baums, so können Informationen nur zwischen Elementen und ihren umschlossenen Kindern fließen.
Es ist jedoch nicht möglich, dass Informationen von ganz vorne, nach ganz hinten, ohne besuchen der Wurzel, durchgereicht werden.
Dies zeigt sich im Folienbeispiel mit dem ~float32_add~:
Würde man nur den Baumkanten folgen, so wüssten wir für ~a~ und ~b~ nicht, welche Additionsoperation wir genau verwenden sollten.
In dieser Situation kommen uns Typen zur Hilfe:
Durch die statische Typannotation wird der Variable an der Definitionsstelle (~int32_t a~) ein Kontext in den Rucksack gepackt, den sie an jeder Verwendungsstelle (~a+b~) mit sich herum trägt. Aus diesem Kontext, der durch die Typen etabliert wird, kann der Übersetzer dann die passende Operation auswählen. Wir haben also einen Link, der Quer zum Baum geht, eingerichtet. Wie genau die Regeln für diese Links aussehen, werden wir im Kapitel über die semantische Analyse sehen.

Der zweite Vorteil von Typen ist, dass sie uns dabei helfen Bugs zu vermeiden.
Denn, in dem Rucksack der Variable steht nicht nur, welche Operationen an der Variable hängen, sondern auch welche Objekte gültige Belegungen für diese Variable sind.
Im Beispiel kann der Übersetzer herausfinden, dass wir ~k1~ keinen ~Dog~ zuweisen können, da Hunde und Katzen ganz unterschiedliche Typen sind. Mit der Typannotation ~Cat k1~ macht der Programmierer die Zusicherung, dass diese Variable zu jedem Zeitpunkt, über die gesamte Laufzeit des Programms, immer nur Katzen gespeichert sind.

Der dritte Vorteil von Typen, betrifft die Kommunikation mit anderen Menschen. Ohne die Angabe von Typen, muss der lesende Programmierer sich überlegen, welcher Art die gespeicherten Objekte sind. Mit Typen, die vielleicht sogar noch, wie im Beispiel, sprechende Namen haben, ist es deutlich einfacher ein Programm zu verstehen.

Zusammengefasst möchte ich also sagen: sehen sie Typen und das Typssystem ihrer Programmiersprache nicht als Feind, der sie davon abhält sich auszudrücken, sondern als Freund und Helfer in der Not, der Sie davon abhält dumme Dinge zu tun.

#+begin_src latex
\dividerframe{Grundbegriffe\\für\\Typen}
  \begin{frame}[fragile]{Was bedeutet ein Typ? Wie interpretieren wir Typen?}
    \bi
    \ii \structure{Strukturell}: Es gibt eingebaute und daraus kombinierte Typen.{
      \bi
      \ii Eingebaute Typen: \lstinline[style=C,morekeywords={int32_t,bool}]{bool, int, int32_t, float, double, char, ...}
      \ii Kompositionen: Referenzen (\codeinline|char *|= Pointer auf \texttt{char}), Arrays (\codeinline|int[10]|).
      \ii \enquote{Wie baue ich meine Datenstrukturen aus einfacheren Datentypen?}
      \ei
    }\medskip
    \ii \structure{Denotationell}: Typen $T$ sind Mengen von Objekten. {
      \bi
      \ii Der Typ \codeinline{uint16_t} \emph{ist} die Menge aller positiver Ganzahlen $0\le x < 65536$.
      \ii Typen sind Prädikate über die Mengen-Mitgliedschaft \siginline{T}{object}{bool}
      \ii \enquote{Welche Regeln und Invarianten gelten für die Objekte hinter diesem Typ?}
      \ei
    }\medskip
    \ii \structure{Abstraktional}: Ein Typ ist ein Interface von konsistenten Operationen.{
      \bi
      \ii \codeinline{int32_t} ist das Interface $\{\texttt{+}_{int32_t}, \texttt{-}_{int32_t}, \texttt{*}_{int32_t}, \ldots\}$
      \ii Der Typ \codeinline{stack_t} besteht aus drei Operationen: \{\texttt{push()}, \texttt{pop()}, \texttt{empty()}\}
      \ii \enquote{Mit welchen Operationen kann ich Objekte dieses Typs manipulieren?}
      \ei
    }
    \ei
    \onslide<2->{
      \bigskip\alert{Alle drei Sichtweisen sind nützlich und keine ist richtiger als die andere.}
    }

  \end{frame}


  \begin{frame}[t,fragile]{Typausdrücke: Strukturelle Notation für Typen}
    \bi
    \ii Wir könnnen Typen strukturell als \structure{Typausdrücke} aufschreiben.{
      \bi
      \ii Komplexere Typen durch die wiederholte Anwendung von \structure{Typkonstruktoren}.\\
      $T$ ist die Menge aller valider Typausdrücke. (Rekursiv!){
        \begin{center}\smallskip
          \signature{pair}{$T \times T$}{T}
  \smallskip
        \end{center}
      }
      \ii \enquote{Ein Paar aus Ganzzahl und einer Menge von Zeichen}
      \ii Mit Typausdrücken wird das formeller: \typeinline{pair(int, set(char))}
      \ei
    }\bigskip
    \ii Typausdrücke sind \alert{Bäume} und Konstruktoren erzeugen innere Knoten.{
      \begin{columns}
        \begin{column}{0.84\textwidth}
          \bi
          \ii Typausdrücke sind strukturell sehr ähnlich zu AST Unterbäumen
          \ii Umwandlung von AST Knoten durch rekursiven Besucher
          \ii Nicht nur Built-In Typen als Blätter: \typeinline{array(int, 2)}
          \ei
        \end{column}\hfill
        \begin{column}{0.15\textwidth}
          \begin{tikzpicture}[small tree,transform canvas={scale=0.8}]
            \node {\emph{pair}}
            child { node {int} }
            child { node {set}
              child { node {char} }
            };
          \end{tikzpicture}
        \end{column}
      \end{columns}
    }
   \ei
  \end{frame}
  #+end_src

Als ersten Schritt unserer Betrachtung über Typen, werden wir uns die Frage stellen: "Was ist so ein Typ überhaupt?" Was ist also, wenn wir all die Spezifika von einzelnen Sprachen wegabstrahieren, die Essenz von Typen? Welche Definition legen wir an, um alle Typen in allen Programmiersprachen zu erfassen? Dazu gibt es allerdings nicht nur eine definitive Antwort, sondern drei verschiedene Sichtweisen (Strukturell, Denotationell, und Abstraktional), die alle nützlich sind und verschiedene Aspekte beleuchten.

Die ~strukturelle~ Interpretation von Typen ist eine sehr technische heransgehensweise an das Problem.
Sie beantwortet die Frage "Was sind Typen?"
damit, dass alles das ein Typ ist, was ich nach den Regeln der Typkomposition bauen kann.
Das ist in etwa so, wie wir sagen können, dass positive Ganzzahlen jene mathetmatischen Objekte sind, die ich durch fortwärendes Inkrementieren, ausgehend von der ~1~, erzeugen kann.
Oder, dass all jenes ein Brot ist, was ich durch Mischen und Backen von Mehl mit Wasser erzeugen kann (später kommen wir wieder auf das Brotthema zurück, versprochen!).
Im Falle von Typen kommt dieses konstrukive Argument dann zu so Schlüssen wie "Pointer auf ~char~" ist ein Typ, weil ~char~ ein Typ ist und "Pointer auf X" eine Kompositionsregel für Typen ist.

Bei der strukturellen Interpretation bilden *Typausdrücke* eine zentrale Rolle.
Sie beschreiben, wie wir komplexere Typen aus einfachen Typen mittels der Anwendung von *Typkonstruktoren* erstellen.
Dabei muss die Sprache eine Menge von eingebauten *Basistypen* (built-in types) mit bringen, die in bereits definiert sind, bevor ein einziges Zeichen Code interpretiert wurde.
Häufig enthält diese initiale Bevölkerung der Menge (T) aller Typen bereits Ganzzahlentypen, Zeichentypen und ein Typ für Wahrheitswerte.

Typkonstruktoren sind dann Funktionen, die eins oder mehrere Elemente der Typmenge als Argumente bekommen und einen neuen Typausdruck erzeugen, der wieder Teil der Menge T wird.
Dabei mag es den geneigten Leser verwundern, dass wir nicht den Rückgabewert der Typkonstruktoren angeben, sondern den noch nicht ausgewerteten Ausdruck. Dies tun wir, da uns nicht konkrete Bitrepresentation von Typen in einem konkreten Übersetzer interessiert, sondern wie diese Typen gebildet werden. Unser "Pointer auf char" voneben würden wir also als ~pointer(char)~ aufschreiben. Um dies zu verdeutlichen, wollen wir uns kurz ein Stück Python anschauen, mit dem wir diese strukturelle Interpretation betrachen können:

#+INCLUDE: ../lst/03-type-basic.py

In diesem minimalsten Typssystem, sehen wir schon mehrere Dinge: Die Existenz von Built-in Types, die Anwesenheit von Typkonstruktoren, und den Unterschied zwischen dem Typausdruck (~POINTER(CHAR)~) und der Kodierung des Typens als Objekts ~(100, 1)~. Prinzipiell können wir mit diesem Typssystem schon unendlich viele Typen erzeugen, indem wir die Konstruktoren, wie ~POINTER~ immer und immer wieder anwenden. Dabei entstehen immer tiefer geschachtelte Typausdrücke.

Zur stukturellen Sicht gehört auch, dass wir diese Typausdrücke, aufgrund ihrere Schachtelung, als Baum aufmalen können. Dabei sehen sie stukturell sehr ähnlich zu unserem AST aus dem letzten Kapitel aus; einem Fakt den wir im Kapitel über die semantische Analyse noch einmal begegenen werden.

Die zweite Brille auf Typen ist die *denotationelle* Sicht auf Typen.
Mit diesem Blick definieren wir einen Typ als ein Prädikat über alle möglichen (imaginären und realen) Objekte (~object~) des Unversums. Sagt das Prädikat "ja" so ist das Objekt von diesem Typen, sagt es nein, so liegt es außerhalb der Umschlossenen Objektmenge des Typen. Mit dieser Brille sind Typen viel viel flexibler gefasst als mit der rein strukturellen Sicht, weil wir einfach irgendein Prädikat angeben müssen um einen Typen zu definieren. So kann die Menge aller geraden Zahlen ein eigener Typ ~int_even~ sein:

#+begin_src python
  def int_even(obj):
      if type(obj) is int and (obj % 2) == 0:
          return True
      return False

  objects = [1, 2, 3, "foo", True, [1,2,3]] # + range(4, 20)
  # Zermelo Fraenkel: [ obj | obj <- objects, int_even(obj)
  print [obj for obj in objects if int_even(obj)]
#+end_src

Hier nutzen wir das Prädikat um eine Liste von Objekten auf jene Objekte zu filtern, die vom entsprechenden Typen sind. Beachten sie, wie wir in unserem Prädikat die Python Primitive ~type()~ verwendet haben um unser Prädikat aus einem Basistypen abzuleiten.

Wenn wir die Regeln eines denotationell definierten Typs strukturierter Aufschreiben als mittels einer Python Funktion, so kann ein Übersetzer daraus auch Eigenschaften der Objektmenge herleiten. So könnte der Optimierer bei der Addition zweier ~int_even~ Variablen wissen, dass das Ergebnis auch wieder ~int_even~ sein wird.

Die dritte Interpretation von Typen ist die ~abstraktionale Sicht~.
Dabei wird ein Typ definiert als eine Menge von validen Operationen auf Objekten des Typ.
Hier wird die Idee des Typkontexts, die wir vorhin aufgegriffen haben (Rucksack), besonders deutlich.
Der Typ *ist* sein Interface, egal wie dieses Interface implementiert ist. Eine Beispiel für die abstraktionale Definition von Typen sind die Interfaces in Java:

#+begin_src java
  interface Object2D {
      float area();
  }

  class MyMain {
      public static void main(String[] args) {
          Object2D obj = ....;
          obj.area();
      }
  }
#+end_src

Hier definieren wir das Interface ~Object2D~, welches durch die Methode ~float area()~ festgelegt ist. Im späteren Verlauf, können wir dann Variablen anlegen, die alle Objekte aufnehmen können, die dieses Interface implementieren. Durch Nutzung des Interface Typs, haben wir über die Variable ~obj~ die Garantie, dass es eine ~area()~ Methode gibt, die eine Fließkommazahl liefert.

#+begin_src latex
  \begin{frame}[fragile]{Äquivalenz von Typen}
    \bi
    \ii Oft gestellte Frage bei Sprachen: Wann sind zwei Typen äquivalent?{
      \bi
      \ii \textbf{Äquivalenz ist}: Ununterscheidbarkeit unter einem bestimmten Aspekt.
      \ii \sample{Beispiel}: "abc" und "foo" sind äquivalent im Speicherverbrauch.
      \ii Unterschiedliche Sprachen verwenden unterschiedliche Äquivalenzen!
      \ei
    }\bigskip
    \ii<2-> \structure{Strukturelle Äquivalenz}: Gleicher Typausdruck = Gleicher Typ{
      \bi
      \ii Typnamen sind nur Abkürzung für den definierten Typausdruck
      \ei
      \vspace{-2ex}
      \begin{columns}[t]
        \begin{column}{0.49\textwidth}
          \begin{code}[tag=Pascal]
            \begin{pascal}
              type R1 = record
                 a, b : integer;
              end;

              type R2 = record
                 a : integer;
                 b : integer;
              end;
            \end{pascal}
          \end{code}

          Beide Definition liefern in Pascal:
          \typeinline{record(("a", integer), ("b", integer))}
        \end{column}\hfill
        \begin{column}<3->{0.49\textwidth}
          \begin{code}[tag=Pascal]
            \begin{pascal}
              type student = record
                 name: string;
                 age: integer;
              end;

              type school = record
                 name: string;
                 age: integer;
              end;
            \end{pascal}
          \end{code}

          Mit reiner struktureller Äquivalenz sind beide Typen unterscheidbar.
          Sollten sie das sein?
        \end{column}
      \end{columns}

    }
    \ei
  \end{frame}

  \begin{frame}[t,fragile]{Namensäquivalenz von Typen}
    \bi
    \ii Rekursive Typdefinitionen sind ein Problem für strukturelle Äquivalenz.{
      \bi
      \ii Ersetzt man jedes Auftreten eins Typnamens durch den Typausdruck, kommt man zu einer endlos tiefen Verschachtelung:
      \ei
      \vspace{-2ex}
  \begin{columns}[t]
    \begin{column}{0.49\textwidth}
      \begin{code}[tag=C]
        \begin{C}
          struct list {
            struct list *next;
          }
        \end{C}
      \end{code}
    \end{column}\hfill
    \begin{column}{0.49\textwidth}
      \begin{code}[background color=typecolor]
        \begin{py}
          record(("next", pointer(
            record(("next", ...)))
          ))
        \end{py}
      \end{code}
    \end{column}
  \end{columns}
    }\bigskip
    \ii<2-> \structure{Namensäquivalenz}: Jede Typdefinition erzeugt einen neuen Typen{
      \begin{quote}
        Wenn der Enwickler sich den Aufwand treibt zwei Definitionen zu schreiben, wird er schon Unterschiedliches gemeint haben.
      \end{quote}

      \bi
      \ii Berechnung der Typausdrücke stoppt an benannten Typen.\\
          \typeinline{type list = record(("next", pointer(type("list"))))}
      \ei

      \hspace{1ex}\includegraphics[width=0.7\textwidth]{fig/03-name-equivalence}
    }
    \ei
  \end{frame}

  \begin{frame}[fragile]{Typnamen und Typaliase}
    \bi
    \ii Mit benannten Typen und Namensäquivalenz: Aliasproblematik {
      \bi
      \ii \codeinline{typedef old_type new_type} (C): Sind dies zwei Namen für den gleichen Typ?
      \ii Nach strikter Namensäquivalenz: Zwei echt unterschiedliche Typen.\\[.5ex]{
        \begin{code}[tag=C]
          \begin{C}
            typedef double celsius_t;
            typedef double fahrenheit_t;
            void heating_set(celsius_t);

            // Namensäquivalenz:   Übersetzerfehler
            // Strukturäquivalenz: Gegrillte Zimmerpflanzen
            fahrenheit_t target = (fahrenheit_t) 100;
            heating_set(target);
          \end{C}
        \end{code}
      }
      \ii C macht nur für \codeinline[style=C]{struct}s Namensäquivalenz, ansonsten Strukturäquivalenz
      \ei
    }\medskip
    \ii<2> Manche Sprachen: Sowohl Typaliase als auch \textbf{abgeleiteten Typen}\\[.5ex]{
      \begin{code}[tag=ADA]
        \begin{ada}
           subtype mode_t is integer;        -- Typalias für Integer
           type celsius_t is new integer;    -- Eigener Typ
           type fahrenheit_t is new integer; -- Eigener Typ
        \end{ada}
      \end{code}
    }
    \ei
  \end{frame}
  #+end_src

Mit unseren drei Brillen haben nur eins geschafft: Wir haben Typen geschaffen, aber bisher können wir mit ihnen nichts anstellen. Ziemlich nutzlose und faule mathematische Objekte so wie sie sind, sich einfach wild von uns erzeugen lassen. Daher wollen wir nun, neben den Typkonstruktoren, weitere Operationen definieren, die auf unserer Typmenge arbeitet. Möglichst nützliche.

Die wahrscheinlich wichtigste Frage für einen Übersetzer ist, ob zwei gegebene Typen *Äquivalent* sind.
Also ob sie das gleiche bedeuten.
Wenn zwei Typen äquivalent sind, so sind ihre Objekte aus Sicht des Typssystems nicht unterscheidbar, vollständig kompatibel zueinander und sowieso best-friends-forever.
Oder um es etwas ausgewählter zu formulieren:
Typäquivalenz ist die strikteste Relation zwischen zwei Typen.
Dabei gibt es zwei unterschiedliche Arten der Typäquivalenz, die in Programmiersprachen auftreten können:
Die Strukturäquivalenz und die Namensäquivalenz.

Bei der *Strukturäquivalenz* sind zwei Typen äquivalent, wenn sie den gleichen Typausdruck haben. Wenn wir in einem Programm einen Typnamen verwenden (Pascal ~type NAME = ...~), so ist das nur eine Abkürzung für den Typausdruck auf der rechten Seite, der NAME selbst wird beim Vergleich ignoriert. Weiterhin werden unterschiedliche Notationen, solange sie zum selben Typausdruck führen, als äquivalent angesehen.

Diese sehr technische Art der Äquivalenz hat allerdings einige gravierende Nachteile, weswegen sie heute kaum noch verwendet wird. Das erste ist, dass es zu einer zufälligen, nicht intendierten Äquivalenz kommen kann, wenn zwei Typen ausversehen die gleiche Strukur haben. So ist der Typ ~student~ und der Typ ~school~ auf den Folien in Pascal, welches strukturelle Äquivalenz verwendet, gleich, obwohl die Intention ganz deutlich, durch zwei Typdefinition, war, dass der Programmierer unterschiedliches meinte.

Das zweite Problem struktureller Äquivalenz sind *rekursive Datentypen*.
Solche rekursiven Typen können auftreten, wenn wir Typen einen Namen geben können und diesen Namen in der Definition des Typs selbst verwenden.
Das Paradebeispiel eines rekursiven Typs, den wir auch schon im Parsing Kapitel besprochen haben, ist die verkettete Liste, bei der jedes Listenelment einen Pointer auf eine (Rest-)Liste beinhaltet.
Das Problem entsteht dann, wenn wir jedes Auftreten des Typnamens einfach durch den Erzeugten Typausdruck ersetzen wollen, weil dann ein endlos tief geschachtelter Typausdruck für diese doch sehr einfache Liste entsteht. Zwar wäre eine endlose Struktur für den Mathematiker erstmal in Ordnung, doch man muss einige Tricks[[fn::[[https://dl.acm.org/citation.cfm?id=1061632][The Equivalence of Modes and the Equivalence of Finite Automata]]] anwenden um dies auf einem endlichen Rechner darzustellen.

Aufgrund dieser Probleme mit struktureller Äquivalenz verwenden die meisten modernen Sprachen *Namensäquivalenz*.
Die Idee dabei ist, dass jede Definition eines Typs, egal wie der Typ strukturiert ist, ein eigener Typ ist, der nur äquivalent zu sich selbst ist.
Wenn der Programmierer sich schon die Mühe macht einen Namen auszusuchen, dann sollten wir immerhin sagen, dass dieser Typ was besonderes ist!

Immer wenn ein Typname in einem Typausdruck verwendet wird, speichern wir dort nur den Namen, nicht den referenzierten Typ selbst, womit unser Typausdruck, selbst für rekursive Typen, wieder ein hübscher hierarchischer Baum wird.


Zusammen mit Namensäquivalenz kommt dann sofort die Frage auf, ob wir *Aliase* von Typen erstellen können:
Ein Typalias ist ein zweiter Typname der den gleichen Typen (nicht nur den gleichen Typausdruck) referenziert und damit voll äquivalent ist.
So kann man in der Sprache C, die für Records Namensäquivalenz verwendet, mittels ~typedef~ einen Typalias erzeugen. In C ist ~typedef~ sogar die einzige Methode einen neuen Typnamen zu definieren{{{see(02-real-language-problems, Lexer Hack)}}}.

Es ist wichtig zu verstehen, dass alle ~typedef~ auf den gleichen Typausdruck äquivalent sind und keine Unterscheidung machen. Dies bedeutet, dass (auf den Folien) ~celsius_t~ und ~fahrenheit_t~ der gleiche Typ (~double~) sind. Daher kann uns der Übersetzer nicht dabei helfen eine Fehlverwendung von ~heating_set~ zu erkennen. Ein ähnlicher Fehler hat die Menscheit schon einen [[https://en.wikipedia.org/wiki/Mars_Climate_Orbiter#Cause_of_failure][Mars Climate Orbiter]] gekostet.

Eine Möglichkeit dies in C zu lösen sind Records mit nur einem Feld. Da für ~struct~ Namensäquivalenz gilt, kann man auf diese Art nicht-äquivalente Typen erzeugen, bei denen der Übersetzer prüft ob wir sie ausversehen vermischen. Zum Beispiel verwendet der [[https://github.com/spotify/linux/blob/master/include/linux/types.h][Linux Kern]] eine Typdefinition für ~atomic_t~ mit der verhindert wird, dass man ausversehen einen atomaren Datentyp mittels ~++~ hochzählt, sondern eine spezielle API ~atomic_add(int i, atomic_t *v)~ verwendet.

#+begin_src C
typedef struct {
	volatile int counter;
} atomic_t;
#+end_src

Andere Sprachen, wie Ada erlauben es nicht nur Typaliase anzulegen (~subtype~), sondern auch Typen, die nicht-äquivalent sind aber den selben Typausdruck haben, mittels ~type~ anzulegen.

* Typische Typen
:PROPERTIES:
:CUSTOM_ID: 03-basic-types
:END:

Nachdem wir eine Idee davon haben, wie man den Begriff des Typen definiert und was man prinzipiell damit machen kann, wollen wir uns nun einige Typen anschauen, die ganz "typisch" sind und in vielen Programmiersprachen vorkommen.
Diese Typen sind ein Basisset was man als Programmierer von einer Sprache erwartet bzw.
erwarten darf.
Dennoch ist es so, dass nicht jede Sprache diese Typen als built-in Typen bereit stellt, sondern sie durch Bibliotheken der Typemengen hinzugefügt wird.
So ist es zum Beispiel typisch, dass der Listentyp nicht in die Sprache eingebaut ist, sondern mittels einer rekursiven Struktur als einfach verkettete Liste "nachgebaut" wird.
An dieser Stelle merken wir bereits, wie die Komposition von built-in Typen uns erlaubt neue Abstraktionen auf bereits Bestehendem zu schaffen.

Die Klasse der geläufigen Typen (um nicht immer typische Typen schreiben zu müssen), lässt sich grob in zwei Kategorien aufteilen.
Zum einen haben wir die *skalaren Typen* die genau ein Objekt beschreiben, dass sich nicht weiter sinnvoll unterteilen lässt.
Die Objekte der skalaren Typen werden also immer "als ganzes" im Program herum gereicht und verwendet.
Im Gegensatz dazu gibt es die *zusammengesetzen Typen*, die sich aus mehreren, erstmal logisch unabhängigen Objekten, zusammensetzen.
Bei diesen Typen ist es möglich, dass ein Teil des Objekts herausgelößt vom Rest betrachtet und herumgereicht werden kann.

Bei einigen Typen lässt sich darüber streiten, ob sie nun skalar oder zusammengesetzt sind.
So kann ein Typ technisch zusammengesetzt sein (weil er als Record implementiert ist), aber dennoch intentional skalar sein, weil er nur als Einheit herum gereicht werden soll.
Ein Beispiel hierfür ist der C++ [[https://de.cppreference.com/w/cpp/memory/shared_ptr][~std::shared_ptr~]].

** Skalare Typen
:PROPERTIES:
:CUSTOM_ID: 03-scalar-types
:END:

#+begin_src latex
  \dividerframe{Typische Typen}

  \begin{frame}[fragile]{Skalare Typen: Aufzählungen und Zahlen}
    \bi
    \ii Skalare Typen beschreiben nicht-weiter zerlegbare Objekte{
      \bi
      \ii Kein Teil eines Skalaren Objekts macht eigenständig Sinn.
      \ii Diskreter Wertebereich, oft mit totaler Ordnung
      \ei
    }\bigskip
    \ii<2-> Aufzählungen oder Enumerations (\codeinline[style=C]{enum{wert0, wert1, ...}}){
      \bi
      \ii Explizite Angabe des Werteberreichs: \hfill\codeinline{enum {red, green, blue}}
      \ii Wahrheitswerte sind ein häufiger Spezialfall: \hfill\codeinline{typedef enum{false, true} bool;}
      \ii Closed-World Assumption ist manchmal schädlich: \hfill\codeinline{enum {female, male}}
      \ei
    }\bigskip
    \ii<2-> Numerische Typen: Ganzzahlen, Fliesskommazahlen, und Dezimalzahlen{
      \bi
      \ii Endlicher, aber meist sehr großer Wertebereich (\codeinline{uint32_t}: $0 \le n < 2^{32}$)
      \ii Speicherung mit (\codeinline{signed}) und ohne (\codeinline{unsigned)} Vorzeichen
      \ii Sehr oft Übereinstimmung mit den Wortbreiten der realen Maschine
      \ii Manche Sprachen erlauben explizite Einschränkung des Wertebereichs:\\[.5ex]{
        \begin{code}[tag=Pascal]
          \begin{pascal}
            type water_temperature = 273..373 (* Kelvin *)
          \end{pascal}
        \end{code}
      }
      \ei
    }
    \ei
  \end{frame}

  #+end_src

Die wichtigsten skalaren Typen sind die *numerischen Typen*, die wir verwenden um Zahlen dazustellen und die in ihrem Abstraktionenrucksack die arithmetischen Operationen mit sich herum tragen.
Durch diese Typen scheint ganz häufig die technische Informatik und die Implementierung von arithmetischen Operationen auf dem realen Prozessor durch.
So haben die ganzen Zahlen häufig einen endlichen Wertebereich, der sich an der Granularität des Speichers (1 Bytes sind 8 Bit) und der Wortbreite (8, 16, 32, 64 Bit) orientiert.
Wir finden mit diesen Typen also Typen wieder, die auch die reale Maschine versteht und *effizient* speichern und verarbeiten kann.
Neben der Anzahl der verfügbaren Bits ist für den Wertebreich der ganzzahligen Typen noch wichtig, ob sie mit Vorzeichen (~signed~) oder ohne Vorzeichen (~unsigned~) gespeichert werden sollen.
Häufig definiert hier die Programmiersprache noch, dass vorzeichenbehaftete Ganzzahlen im Zweierkomplement gespeichert werden, weil hierfür effiziente Hardwareoperationen zur Verfügung stehen.

Ein wichtiger Punkt bei diesen numerischen Typen ist die Frage:
Was passiert eigentlich, wenn der Wertebereich überschritten wird.
Also was passiert, wenn ich bei einem ~int8_t~, der gerade den Wert 128 hat eins aufaddiere?
An dieser Stelle kann sich eine Programmiersprache sehr unterschiedliche Entscheidungen treffen:
Die eine Möglichkeit ist, dass sie ein Überlaufverhalten definiert und bestimmt dass ~(int8_t)128++~ zum Wert -127 führt.
Dadurch klopfen wir allerdings auch fest, dass die ganzen Zahlen das Verhalten des Zweierkomplements zeigen müssen.
Soll ein Programm nun aber auf einer Einerkomplementmaschine ausgeführt werden, so muss der Übersetzer das Verhalten des Zweierkomplements aufwändig emulieren um die versprochene Sprachsemantik zu erfüllen.
Die andere Möglichkeit, die zum Beispiel von C gewählt wird, ist den Ganzzahlüberlauf als *undefiniertes Verhalten* zu markieren.
Dies bedeutet, dass der Übersetzer frei entscheiden kann, was passiert, wenn eine vorzeichenbehaftete Ganzzahl überläuft. Auf diese Weise können Ganzzahlen sowohl auf einem Rechner mit Einerkomplement als auch auf einem Zweierkomplementrechner effizient verarbeitet werden[fn::Integer Overflows sind allerdings ein schwerwiegendes Problem in real existierender Software.
[[http://www.cs.utah.edu/~regehr/papers/tosem15.pdf][Understanding Integer Overflow in C/C++]], Dietz et. al., TOSEM 2015].

Neben den ganzzahligen Typen gibt es dann normalerweise noch Fließkommazahlen mit einfacher Genauigkeit (~float~, 32 Bit) und doppelter Genauigkeit (~double~, 64 Bit).
Diese Fliesskommazahlen haben ein wechselnde Genauigkeit über ihren ganzen Wertebreich, weswegen für Finanzanwendungen noch Festkomma- und Dezimalzahltypen zur Verfügung stehen können.
Bei den Dezimalzahlen mit festen Komma gibt der Typ dann nicht die Anzahl der verwendeten Bits an, sondern wieviele Dezimalstellen vor und nach dem Komma präzise gespeichert werden. So kann der Typ ~DECIMAL(6,2)~ in der MySQL Datenbank alle Zahlen von -9999.99 bis 9999.99 auf den Cent genau speichern.

Neben den Zahlen mit endlichem Wertebereich gibt es auch noch die ~bignum~ Typen. Bei diesem Typen garantiert die Sprache, dass es niemals zu einem Überlauf kommt. Technisch werden, wenn die Zahl überlaufen sollte einfach mehr Speicher allokiert. Ein Beispiel für so eine Sprache, die implizit von Ganzzahlen endlicher Länge auf ~bignums~ wechselt ist Python:

#+begin_src python
import sys
MAX_INT = sys.maxsize # Der größte Integer der als <type 'int'> dargestellt werden kann.
# <type 'int'> hat endliche Länge
# <type 'long'> ist ein Bignum
print [type(1), type(MAX_INT), type(MAX_INT+1), type((MAX_INT+1)-1)]
#+end_src

Neben den numerischen Typen gibt es dann noch die Aufzählungstypen, bei denen der Entwickler selbst einen Typ als eine menge diskreter Werte definieren kann.
Diese Typen sind nützlich, wenn eine Menge von Werten mit lesbaren Namen versehen werden soll.
Häufig garantiert die Sprachsemantik dann noch, dass die Elemente dieser Aufzähl eine totale Ordnung haben und man, im Beispiel ~red < green~ machen kann.
Dies rührt daher, dass die Aufzählungstypen normalerweise auf Ganzzahlen abgebildet werden.
Bei manchen Sprachen ist die Abstraktion der Aufzählungstypen allerdings löchrig und man kann einer Variable vom Aufzählungstyp auch einen Wert zuweisen, der nicht in der Aufzählung vorkommt:

#+begin_src C
typedef enum {red, green, blue} color_t;

color_t invalid_color = 1000;
#+end_src

#+begin_src latex
  \begin{frame}[t,fragile]{Skalare Typen: Zeiger und Funktionen}
    \bi
    \ii Zeiger sind gespeicherte Referenzen auf Objekte vom Basistyp {
      \begin{center}
        \includegraphics[width=0.5\textwidth]{fig/03-pointers}
      \end{center}
      \bi
      \ii Minimales Interface (abstraktional): \siginline{dereference}{pointer(T)}{T}
      \ii Verschiedene Zeigertypen geben unterschiedliche Referenzen{
        \bi
        \ii Universeller Zeiger in C garantiert nichts (\codeinline{T*})
        \ii C++ Referenzen zeigen immer auf valides Objekt (\codeinline[style=CPP]{T&})
        \ii Für jedes Objekt, maximal ein \textbf{eindeutiger Zeiger} (\codeinline[style=CPP]{std::unique_ptr<T>})
        \ei
      }
      \ei
    }\medskip
    \ii<2-> Funktionstypen beschreiben den Rückgabetyp und die Parametertypen\\{
      \bi
      \ii Strukturell: Typausdruck für \codeinline{strlen} ist \typeinline{func(size\_t, pointer(char))}
      \ii Abstraktional: \siginline{call}{func(R,\ldots) $\times$ \ldots}{R} (\enquote{Funktionen sind aufrufbar})
      \ii Denotational: Maschinencode der Funktion ist ein Objekt dieser Typen.
      \ei
    }
    \ei
  \end{frame}
#+end_src

Weiterhin sind auch die Zeiger- bzw.
*Referenztypen* skalar.
Die Objekte dieser Typen sind nicht an sich nützlich, sondern sie enthalten Referenzen auf andere Objekte.
Im Beispiel ist der Wert ~0x1234~ das Zeigerobjekt selbst und es referenziert das Objekt ~500~.
Um diese Referenzierung ins Typssystem einzubinden, sagt ein Zeigertyp häufig nicht nur "ich bin eine Referenz", sondern auch "Ich bin eine Referenz auf ein Objekt vom Typ X.
In unserem Fall haben wir einen ~pointer(int)~ vor uns; das referenzierte Objekt ist also immer eine Ganzahl, niemals aber ein double.

Als kleinste Menge an Abstraktionen muss ein Zeigertyp, um nützlich zu sein, dereferenziert werden können.
Durch das dereferenzieren kommen wir zur Laufzeit zum referenzierten Objekt.
Spannend an diesem ~dereference~ Interface ist seine parametrische Schreibweise, bei der die Signatur andeutet, dass der Pointee-Type T aus dem Typausdruck ~pointer(T)~ ausgepackt und als Rückgabetyp verwendet wird.
Mehr zu dieser Art der Typmuster werden wir im Unterkapitel über Polymorphie lernen.

In Sprachen kann es Unterschiedliche Arten von Referenztypen geben, die, neben der reinen Objektreferenzieren, noch weitere Eigenschaften haben.
So gibt der C++ Referenztyp ~T&~ die Garantie, dass immer ein valides Objekt referenziert ist.
Der ~std::unique_ptr~ stellt sicher, dass es immer nur eine Referenz für das referenzierte Objekt zu einem Zeitpunkt gibt.
Dies bedeutet, dass der Besitzer des ~std::unique_ptr~ auch das Objekt alleinig "besitzt".

Im Zoo der skalaren Typen spielen die Funktionstypen eine ganz zentrale Rolle, wenn auch eine sehr sonderbare, denn Funktionsobjekte können nicht verändert werden und nur ganz wenige Sprachen erlauben das Anlegen neuer Funktionsobjekte zur Laufzeit (JavaScript und Python sind Beispiele hierfür).
Ein Funktionstype beschreibt das Interface, dass eine Funktion aufweißt:
Also welche Typen haben die Parameter, und was ist der Rückgabetyp.
Jede Funktion hat einen Funktionstyp, der direkt aus ihrere Signatur, durch weglassen der Parameternamen, berechnet werden kann.
Die einzige Operation auf einem Funktionstyp ist der Aufrufoperator ~call~, der eine Funktion mit ihrer Argumentliste füttert und den Rückgabewert, korrekt getypt mit ~R~, zurückliefert.

Eigentlich können wir Funktionstypen nicht verwenden um Variablen zu typen: da wir keine neuen Funktionsobjekte anlegen können, können wir sie auch nicht zuweisen bzw. kopieren. Daher können wir höchstens einen Zeiger auf ein Funktionsobjekt, einen *Funktionszeiger*, herumreichenn: ~pointer(func(size_t, pointer(char)))~.
Da diese strikte Trennung zwischen Funktion und Funktionszeiger allerdings eher müßig ist, wird häufig nicht besonders Trennscharf zwischen Funktion und Funktionspointer unterschieden.

Ein anderer wichtiger Aspekt, der nicht offensichtlich ist, aber der eigentlich aus der Orthogonalität von Typkonstruktoren hervorgeht ist, dass wir Funktionstypen definieren können für Funktionen die (Zeiger auf) Funktionen zurückgeben:
~func(func(size_t, pointer(char)), int)~.
Dieser Typausdruck besagt, dass die Funktion einen ~int~ übergeben bekommt und eine Funktion vom Typ ~func(size_t, pointer(char))~ zurückliefert.
Zumindest in C ist die Syntax für solche Funktionen allerdings mehr als unintuitiv, weshalb man dort lieber ein ~typedef~ verwenden sollte:

#+begin_src C
#include <string.h>

size_t (*func(int param)) (const char* ) {
    return &strlen;
}

typedef size_t (*func_ptr_t)(const char*);

func_ptr_t func2(int param) {
    return &strlen;
}
#+end_src

In Sprachen in Funktionen als Rückgabewert häufiger vorkommt gibt es deutlich intuitivere Notationen für solche Funktionstypen. In Haskell Notation wäre diese Funktion dann:

#+begin_src haskell
  func:: int -> const char* -> size_t
  -- '->' ist Rechtsbindend und daher äquivalent zu:
  func:: int -> (const char * -> size_t)
#+end_src

** Zusammengesetzte Typen
:PROPERTIES:
:CUSTOM_ID: 03-composite-types
:END:

#+begin_src latex
  \begin{frame}[fragile]{Zusammengesetzte Typen: Strukturen}
    \begin{columns}
      \begin{column}{0.49\textwidth}
        \begin{code}[tag=C]
          \begin{C}
            typedef struct {
              int    feld_1;
              double feld_2;
            } foo_t;
          \end{C}
        \end{code}
      \end{column}\hfill
      \begin{column}<2->{0.49\textwidth}
        \begin{code}[tag=C]
          \begin{C}
            union {
              int    feld_1;
              double feld_2;
            };
          \end{C}
        \end{code}
      \end{column}
    \end{columns}

    \bi
    \ii Records subsumieren endlich viele, jedoch heterogen getypte, Elemente{
      \bi
      \ii Die einzelnen Elemente heißen Felder und haben einen Typ und einen Namen
      \ii Namen müssen normalerweise statische Bezeichner sein
      \ii Minimales Interface: \siginline{dot\_operator}{record(..., (name, T), ...) $\times$ name}{T}
      \ei
    }\medskip
    \ii Records kommen in fast allen Sprachen in diversen Geschmäckern vor: {
      \bi
      \ii Java Klassen sind auch Records, aber noch viel viel mehr...
      \ii Fortran90: Der Übersetzer darf Felder umsortieren um Speicher zu sparen
      \ii Haskell: Tupel sind so etwas wie Records ohne Feldnamen
      \ei
    }
    \medskip
    \ii<2-> Bei varianten Records (Unions) ist maximal ein Feld gültig {
      \bi
      \ii Alle Felder des Records nehmen den gleichen Speicher ein.
      \ii Unions sind oft die einzige (erlaubte) Möglichkeit das Typsystem zu umgehen
      \ei
    }
    \ei
  \end{frame}
  #+end_src


Die anderen geläufigen Typen sind die zusammengesetzten Typen.
Die Objekte dieser Typen bestehen aus mehrere Subkomponenten/Elementen zusammen, die auch herausgelößt Sinn ergeben.
So hat eine Liste viele Listenelemente; jedes einzelne Listenelement ergibt auch ohne die Liste einen Sinn.
Es gibt, ganz allgemein gesprochen, drei verschiedene Kategorien von komponierenden Typen:
Strukturen, Sequenzen und Abbildungen.

Bei den *Strukturtypen* sind die Subkomponenten /eindeutig/ benannt (~name~), aber ihre Anzahl ist endlich und Teil des Typausdrucks.
Durch diese eindeutige Benennung der Elemente ist zu jedem Zeitpunkt eine eindeutige Wiederauffindbarkeit, anhand des Strukturtyps und des gegebenen Namens, gewährleistet.
Das Wiederauslesen der Elemente geschieht durch den ~dot_operator~, der den Typausdruck des Strukturtypen inspiziert:
Auf Ebene der Objekte, holt der Operator das Element mit dem entsprechenden Namen heraus und gibt es zurück.
Auf Ebene der Typen, hat der Operator den Elementtyp mit dem entsprechenden Namen als Rückgabetypen.
Wenn der Rückggabetyp des ~dot_operators~ eindeutig und zur Übersetzungszeit festgelegt sein soll, was für die meisten übersetzten Sprachen der Fall ist, so muss der ~name~ eine Konstante sein.
Etwas was dadruch erreicht wird, dass man Bezeichner als Strukturtypnamen verwendet.
Alle anderen Regeln, die für Strukturtypen gelten, wie dass die Elemente in einer gewissen Ordnung gespeichert werden, sind sprachspezifisch.

Um das ganze etwas plastischer zu machen, wollen wir uns ansehen wie C ~struct~ Typen auf unser Modell von Strukturtypen passen:

#+begin_src C
  typedef struct {
     int    feld_1;
     double feld_2;
  } foo_t ;
  // type foo_t
  //    = record((int,    field_1),
  //             (double, field_2))

  ...
  struct foo var;
  var.feld_1 = 1;    // dot_operator(foo_t, feld_1) -> int
  var.feld_2 = 1.5;  // dot_operator(foo_t, feld_2) -> double
#+end_src

Der Strukturtyp hat zwei Elemente mit den Namen "feld_1" und "feld_2; beide Elemente haben unterschiedliche Typen (int, double).
Der ~dot_operator~ ist als ~.~ in der Sprache als Infixoperator eingebaut und als zweites Argument werden Bezeichner verwendet, wie sie aus dem Scanner fallen.

Es gibt zwei geläufige Sonderformen von Strukturtypen:
Tupel und variante Records.
Bei Tupeln sind die Elemente nur implizit über ihre Position im Tupel benannt; der Benutzer muss sich keinen expliziten Namen ausdenken.
Bei Varianten Records, in C ~union~, ist zur Laufzeit immer nur ein Element gültig und alle Elemente teilen sich den gleichen Speicherplatz.

  #+begin_src latex
  \begin{frame}[fragile]{Zusammengesetzte Typen: Sequenzen}
    \begin{columns}[b]
      \begin{column}{0.49\textwidth}
        \begin{code}[tag=Haskell]
          \begin{haskell}[basicstyle=\scriptsize\ttfamily]
            a = [2, 3] -- `\typeinline{list(int)}`
            b = 1 : a  -- = cons(1, [2, 3])
            T = tail b -- `\typeinline{list(int)}`, [2,3]
            H = head b -- `\typeinline{int}`, 1
          \end{haskell}
        \end{code}
      \end{column}\hfill
      \begin{column}{0.49\textwidth}
        \begin{code}[tag=C]
          \begin{C}
            struct list {
              int          value;
              struct list *next;
            };
          \end{C}
        \end{code}
      \end{column}
    \end{columns}

    \bi
    \ii Sequenztypen sind homogen getypte und (un)geordnete Container  {
      \bi
      \ii Bekanntester Sequenztyp ist die (einfach verkettete) Liste: \typeinline{list(T)}
      \ii Minimales Interface: Nur Zugriff auf das erste Element und die Restelemente:\\
         \siginline{head}{list(T)}{T} \siginline{tail}{list(T)}{list(T)}
      \ei
    }\medskip
    \ii Listen sind rekursive definiert und werden oft mit Records nachgebaut{
      \bi
      \ii Die Restliste ist selbst wieder eine Liste oder \codebox{nil} (Leere Liste)
      \ii Mittels einem rekursivem Record kann man Listentypen emulieren
      \ei
    }\medskip
    \ii Abweichungen von strikter Homogenität und Einfügeordnung möglich{
      \bi
      \ii Python Listen (\codeinline{[1, "x", 3.4]}) garantieren nur minimalen Typ: \typeinline{list(object)}
      \ii Sets sind ungeordnete Mengen (Java: \codeinline[style=Java]{HashSet<Integer>})
      \ei
    }
    \ei
  \end{frame}

  #+end_src

Der zweite geläufige zusammengesetzte Typ sind *Sequenzen*.
Bei Sequenzen erlauben wir, dass die Anzahl der Elemente zur Laufzeit variabel und potentiell unendlich ist.
Um dennoch eine eindeutige Typisierung zu bekommen, verlangen wir, dass alle Elemente der Sequenz den gleichen Typ haben.
Um auf die Elemente von Sequenzen zugreifen zu können, muss die Sequenz 2 Operationen (~head~, ~tail~) anbieten.
Dabei liefert ~head~ ein Element, bei geordneten Sequenzen das erste, und ~tail eine Sequenz mit allen anderen Elementen zurück.

Die einfachste Variante eines Sequenztyps ist die einfach verkettete Liste, über die wir schon genug geredet haben.
Aber auch andere Sequenzen wie eine priorisierte Warteschlange (Java:
~PriorityQueue<T>~)oder eine ungeordnete Menge (Java:
~HashSet<T>~) fallen in die Kategorie Sequenzen.
In jedem Fall können wir eins ums andere Element aus der Sequenz entfernen und sind uns immer sicher ein Objekt vom Typ T in Händen zu halten.

#+begin_src latex
   \begin{frame}[fragile]{Zusammengesetzte Typen: Abbildungen}
      \begin{columns}[b]
        \begin{column}{0.49\textwidth}
          \begin{code}[tag=C]
            \begin{CPP}[basicstyle=\scriptsize\ttfamily]
              // `\typeinline{array(int,10)}`, `\typeinline{map(int,int)}`
              int rgb[10];
              // `\typeinline{map(int, map(int, int))}`
              char matrix[20][20];
          \end{CPP}
        \end{code}
      \end{column}\hfill
      \begin{column}<2->{0.49\textwidth}
        \begin{code}[tag=C++]
          \begin{CPP}[basicstyle=\scriptsize\ttfamily]
            std::map<std::string, int> x;
            x["y"] = 23;
            x["z"] = x.at("y") + 100;
          \end{CPP}
        \end{code}
      \end{column}
    \end{columns}

    \bi
    \ii Abbildungstypen: Zuordnung zwischen einem Index- und einer Wertetyp{
      \bi
      \ii Indexmenge und Wertemengen sind homogen getypt
      \ii Vordefiniert-beschränkte oder dynamisch-wachsende Abbildungsgröße
      \ii Wahlfreier Zugriff mit dynamischen Index \siginline{get}{map(K, V) $\times$ K}{V}
      \ei
    }\medskip
    \ii Arrays sind die einfachste (und effizienteste) Abbildung {
      \bi
      \ii Indextyp ist immer \typeinline{int}, Indexmenge ist zusammenhängend und beschränkt
      \ii Effizienter Elementzugriff und dichte Speicherung möglich
      \ii Manche Sprachen erlauben variabel lange Zeilen in mehrdimensionalen Arrays
      \ei
    }\medskip
    \ii<2-> Assoziative Arrays wachsen und erlauben beliebige Indextypen{
      \bi
      \ii Namen: Dictionary (Python), Hash (Ruby), Table (Lua), Map (Rust, C++)
      \ii In Skriptsprachen wird oft die Homogenität aufgegeben: \typeinline{map(object,object)}
      \ei
    }
    \ei

  \end{frame}
#+end_src

Die dritte Variante von zusammengesetzten Typen sind die *Abbildungstypen*.
Ihr Typkonstruktor ~map(K,V)~ bekommt (mindestens) zwei Typen als Argument, die die Indexmenge (~K~) und die Wertemenge (~V~) der Abbildung typisieren.
Beide Mengen sind, wie bei den Sequenzen, homogen typisiert.
Der Zugriff auf die Elemente von Abbildungen erfolgt, anderes als bei Sequenzen, wahlfrei durch ~get()~, welches aus einem Abbildungsobjekt und einem Objekt der Indexmenge das vorher zugewiesene Objekt der Wertemenge liefert.
Da sowohl Indices als auch Werte homogen getypt sind, ist die Signatur von ~get()~ Anhand des Typausdrucks des Abbildungstypen eindeutig.
Etwas informeller Ausgedrückt: Mit Abbildungen kann ich etwas unter einem Index speicher, und unter dem gleichen Index wiederfinden.

Der wohl geläufigste Abbildungstyp, den man zuerst nicht als solchen identifiziert, ist das *Array*.
Bei Arrays ist der Datentyp der Indexmenge auf ~int~ festgelegt ist, die Indexmenge kompakt (ohne Lücken) ist, und beim Erstelen der Abbildungsobjekte angegeben werden muss. Dies geschieht durch die Angabe der Arraygröße und den Startindex.
Häufig ist der Startindex noch per Sprachregel, wie bei C, auf 0 festgetackert.
Allerdings wird die Zugehörigkeit von Arrays zu den Abbildungstypen klarer, wenn wir uns anschauen, das Sprachen, wie Pascal, gibt die es dem Programmierer erlauben den Startindex frei zu wählen. Wenn wir einen Verein mit mindestens 3, aber maximal 100 Mitgliedern typisieren wollen können wir dort schreiben:

#+begin_src pascal
type verein_t = array[3..100] of mitglied_t;
#+end_src

Die ander geläufige Variante von Abbildungstypen sind die *assoziativen Arrays*, bei denen der Benutzer den Datentyp der Indexmenge frei wählen kann.
Diese assoziativen Arrays sind unter sehr vielen Namen bekannt, funktionieren aber eigentlich immer ziemlich gleich.
Eine Besonderheit sind viele Skriptsprachen, bei denen die Homogenitätsanforderung, sowohl für die Indices als auch für die Werte, aufgehoben wird.
Aus Sicht des Typsystems hat die Abbildung also den Typ ~map(object, object)~:
Wir stecken Objekte von irgendwelchen Typen rein, und vielleicht finden wir ein assoziiertes Objekt von irgendeinem anderen Typ.

Der geneigte Leser wird sich da Fragen:
Was ist eigentlich der Unterschied zwischen einer Struktur und einer Abbildung?
Die Antwort darauf ist, dass im ganz allgemeinen Fall ~get()~ und ~dot_operator()~ das gleiche sein können.
Normalerweise lassen wir aber beim ~dot_operator~ nur konstante Namen zu, während wir bei ~get()~ den Index dynamisch berechnen können.
Es gibt, mit Lua, sogar eine Programmiersprache, die nur einen solchen flexiblen Abbildungsttypen anbietet und sowohl Sequenzen als auch Strukturen nur Sonderfälle sind von Abbildungen sind.

* Polymorphismus
:PROPERTIES:
:CUSTOM_ID: 03-polymorphism
:END:
#+begin_src latex
  \dividerframe{Polymorphismus}

  \begin{frame}[fragile]{Polymorphismus macht Code flexibel}
    \textbf{Bisher:} Zwei Typen sind entweder gleich oder haben nichts gemein.
    \bigskip

    \bi
    \ii Typen haben jedoch oft gemeinsame Aspekte und sind irgendwie ähnlich{
      \bi
      \ii Strukturell:   \codeinline[style=C]{struct point2D {int x,y}} \codeinline[style=C]{struct point3D {int x,y,z}}
      \ii Denotational:  \typeinline{uint8\_t} $\in$ \typeinline{uint16\_t} $\in$ \typeinline{uint32\_t} $\in$ \typeinline{uint64\_t}
      \ii Abstractional: \siginline{lengthIntList}{list(int)}{int} \siginline{lengthFloatList}{list(float)}{int}
      \ei
    }\medskip
    \ii \structure{Monomorphe Typsysteme} beachten nur Äquivalenz und sind \ALERT{inflexibel} {
      \bi
      \ii Codeduplikaten: \codeinline{printX_2D()}, \codeinline{isEven_u8()}, \codeinline{lenghtFoobarList()}
      \ii Ständige explizite Konvertierungen zwischen ähnlichen Typen:\\
          \codeinline[style=C]{struct point3D x; struct point2D x_ = {x.x, x.y};}
      \ei
    }\medskip
    \ii Polymorphismus erlaubt es ähnliche anstatt nur gleicher Typen zu haben{
      \bi
      \ii Polymorpher Code darf sich nur auf die Gemeinsamkeiten verlassen
      \ii Subtypes: \enquote{Jeder 3D Punkt ist auch ein 2D Punkt}
      \ii Parametrisch: \enquote{Funktion verarbeitet alle Listen unabhängig vom Elementtyp}
      \ei
    }
    \ei
  \end{frame}

  \begin{frame}[fragile]{Typkompatibilität}
    \bi
    \ii Neben Typäquivalenz, brauchen wir auch noch die Typkompatibilität {
      \lstset{style=smaller}
      \begin{columns}
        \begin{column}{0.49\textwidth}
          \begin{code}[tag=C]
            \begin{C}[style=C,morekeywords={uint8_t, uint16_t, uint32_t}]
              uint16_t x = (uint8_t)10;
              uint32_t y = x + 13;
            \end{C}
          \end{code}
        \end{column}\hfill
        \begin{column}{0.49\textwidth}
          \begin{code}[tag=C++]
            \begin{CPP}[style=CPP,morekeywords={S, T}]
              S *x;
              T *y = x;
            \end{CPP}
          \end{code}
        \end{column}
      \end{columns}

      \medskip
      \structure{Substitution}:
      Kann ich \codeinline{T *} sicher durch \codeinline{S *} ersetzen?
    }\medskip
    \ii \enquote{Sicher} hat dabei viele unterschiedliche Interpretationen{
      \bi
      \ii Speicher: Die S Datenstruktur ist kompatibel zur T Datenstruktur.
      \ii Abstraktionen: S kann in jedem Context wie T verwendet werden.
      \ii Semantik: S verhält sich in jedem Context entsprechend wie T.
      \ei
    }\medskip
    \ii<2> \alert{Kein} Typsystem kann alles abfangen und komplette Sicherheit bieten{
    \vspace{-2ex}
  \begin{columns}[t]
    \begin{column}{0.49\textwidth}
      \begin{code}[tag=Base.java]
        \begin{java}
          class Base {
            public MyObj alloc() {
              return new MyObj(23);
            };
          }
        \end{java}
      \end{code}

    \end{column}\hfill
    \begin{column}{0.49\textwidth}
      \begin{code}[tag=Derived.java]
        \begin{java}
          class Derived extends Base {
            public MyObj alloc() {
              eraseUserDisk();
              return null;
            };
          }
        \end{java}
      \end{code}

    \end{column}
  \end{columns}
  }
  \ei
  \end{frame}

  #+end_src

Bisher haben wir uns nur mit Typäquivalenz beschäftigt.
Die bedeutet, dass zwei Typen entweder gleich oder unterschiedlich waren.
So ein bisschen gleich gab es nicht.
Typsysteme, die nur, oder beinahe nur, diese Sicht auf Typen haben nennt man *Monomoprhe Typsysteme*.
Jeder Typ hat genau eine Gestalt[fn::Griechisch:
mono=eins, morph=Gestalt].
Dies bedeutet allerdings auch, dass jede Operation und jede Funktion nur mit einem Satz an Typen aufgerufen werden kann.
Sollen ähnliche Verarbeitungsschritte auf unterschiedlichen Typen ausgeführt werden so hat man 2 Möglichkeiten:
Entweder man stellt für jeden Typ einen eigenen Satz an Operationen bereit (~printX_2D()~, ~printX_3D()~), was einen hohen Grad an Codeduplikation zur Folge hat. Oder, die andere Möglichkeit, ist, dass man explizit die Daten in den anderen Typ konvertiert. Bei Strukturtypen kann dies bedeuteten, dass die einzelnen Elemente ausgepackt und in ein anderes Strukturobjekt kopiert werden müssen. Das ist Fehleranfällig, langsam und führt zu einem Mehrverbrauch an Speicher.

Allerdings sind Typen vielleicht garnicht immer so unterschiedlich, wie das eine Monomorphe Sicht der Dinge nahe legen würde, sondern es gibt oft Gemeinsamkeiten.
Und es sind diese Gemeinsamkeiten, die der Polymorphismus einfängt und im Typsystem formalisiert.
Wenn ein Typ Polymorph ist, bedeutet dass, dass der gleiche Typ unterschiedliche Rollen einnehmen bzw.
sich so wie ein anderer Typ verhalten kann.
Am Beispiel des 3D Punktes:
Durch ignorieren der 3.
Dimension kann sich jeder 3D Punkt wie ein 2D Punkt verhalten.
Der 3D Punkt schlüpft also in die Rolle, und betreibt Mimikri, wie der 2D Punkt.
Ein anderes Beispiel, dem wir nachgehen werden ist der Parametrische Polymorphismus, bei dem die Gemeinsamkeiten in einem generischen Typen gebündelt werden. Anstatt ein Listentyp jeweils für int-Liste, float-Liste, und double-Liste anzulegen, führen wir einfach den generischen Typ 'Liste von beliebigen Elementen' ein.

Allerdings ist die Sache doch nicht ganz so einfach wie sie scheint, wenn wir sagen:
Ein Typ soll sich halt so wie der andere Verhalten.
Wenn jeder Typ einfach in die Rolle eines anderen schlüpfen könnte, würden alle Sicherheiten und Garantien verlieren, die uns das Typssystem versprochen hat.
Daher brauchen wir Regel, wann ein Typ wie Polymorph sein kann. Und dazu brauchen wir neben der Typäquivalenz, noch den Begriff der *Typkompatibilität*.

Wenn ein Typ S kompatibel ist mit einem Typ T, so kann S sich als T ausgeben; man kann T durch S, ohne Konvertierungen, *substituieren*.
Je nach Kontext benötigen wir, um dies Typsicher machen zu können, unterschiedliche formen von Kompatibilität:
Wollen wir nur auf die Felder einer Struktur zugreifen, so reicht es wenn S alle Elemente von T enthält und diese im Speicherlayout an der gleichen Stelle plaziert sind.
Möchte man T-Operationen auf dem S-Objekt ausführen, so müssen diese eine kompatible Schnittstelle haben.
Will man das S-Objekt als vollständiges Substitut verwenden, so muss nicht nur die Schnittstelle, sondern auch das Verhalten kompatibel sein.
Allerdings kann ein Typssystem nicht all diese Fälle, insbesondere den letzten, wie das Beispiel auf den Folien zeigt, abfangen.

#+begin_src latex
  \begin{frame}{Arten des Polymorphismus}
    \btAnimation[width=\textwidth]{center, padding, range=1-2:<1->}{fig/03-polymorphismus}
  \end{frame}

  \begin{frame}[t,fragile]{Inklusion: Subtypen}
    \begin{btBlock}[type=alert]{\ALERT{Ziel:} Behandlung unterschiedlicher Typen \textbf{ohne} Konvertierung}
      Der Code für Supertypen solls auch Subtypen verarbeiten können.
    \end{btBlock}

    \begin{btBlock}{Subtypen sind Subsets: $S \subseteq T$}
      Da ein Typ T die Menge seiner Objekte (denotational), ist ein Subtyp S eine Untermenge vom (Super)typ T. Jedes S ist auch ein T.
    \end{btBlock}

    \bigskip
    \bi
    \ii<2-> \structure{Subranges}: Subtyping durch Einschränkung des Werteberreichs {
      \bi
      \ii Ada: \codeinline[]{subtype percent_t is integer range 0..100;}
      \ii Wer \codeinline{integer} verarbeiten kann, kann auch \codeinline{percent_t} verarbeiten.
      \ei

      \begin{code}[tag=Pascal]
        \begin{pascal}[style=smaller]
          type percent_t = 0..100;
          procedure PrintInteger(j : integer);
          ...
          var completed : percent_t;
          completed := 37;
          PrintInteger(completed);
        \end{pascal}
      \end{code}
    }
    \ei
  \end{frame}

  \begin{frame}[fragile]{Inklusion: Subtyping durch Vererbung}

    \medskip

    \bi
      \ii Man proklamiert, intentional, dass es eine Subtyp Beziehung gibt.{%
        \bi
        \ii Zur Erhaltung der Kompatibilität, muss Derived alle Felder von Base erben. {
    \begin{columns}
      \begin{column}{0.49\textwidth}
        \begin{code}[tag=C++]
          \begin{CPP}[style=smaller]
            struct Base {
              int x;
            };
          \end{CPP}
        \end{code}\\
        \typeinline{type Base = record(("x", int))}
      \end{column}\hfill
      \begin{column}{0.49\textwidth}
        \begin{code}[tag=C++]
          \begin{CPP}[style=smaller]
            struct Derived : public Base {
              int y;
            };
          \end{CPP}
        \end{code}\\
        \typeinline{type Derived = record(("x", int), ("y", int))}
      \end{column}
    \end{columns}\medskip
        }
        \ii<2-> Zur Erhaltung der Abstraktionskompatibilität muss selbiges auch für das angebotene Interface geschehen.
        \ei
      }\medskip
      \ii<3-> Bei C++ wird die Kompatibilität sofort am Assembler sichtbar.{
        \bi
        \ii Geerbte Felder werden \enquote{vorne} eingefügt: \codeinline{offsetoff(Derived, x) == 0}
        \ei
      \begin{columns}
        \begin{column}{0.49\textwidth}
          \begin{code}[tag=C++]
            \begin{CPP}
              int getX(Base* o) {
                return o->x;
              }

              int getY(Derived* o) {
                return o->y;
              }
            \end{CPP}
          \end{code}
        \end{column}\hfill
        \begin{column}{0.49\textwidth}
          \begin{code}[tag=RV32]
            \begin{asm}
              getX: # (Base * a0)
                 lw   a0, 0(a0)
                 ret

              getY: # (Derived * a0):
                 lw   a0, 4(a0)
                 ret
            \end{asm}
          \end{code}
        \end{column}
      \end{columns}
      }
      \ei
    \end{frame}
    #+end_src


In dieser Vorlesung wollen wir uns mit dem universellen Polymorphismus beschäftigen. Dabei geht es darum, dass die gleichen Typen in allen Kontexten gleich Kompatibel sind. Beim ad-hoch Polymorphismus, der uns in den nächsten 2 Vorlesungen begegnen wird, wird in jedem Kontext einzeln festgestellt ob die gerade vorliegenden Typen und Operationen kompatibel sind bzw. kompatibel gemacht werden können. Einen genaueren Überblick über das Thema des Polymorphismus, finden sie in dem Artikel [[http://lucacardelli.name/Papers/OnUnderstanding.A4.pdf][On Understanding Types,Data Abstraction, and Polymorphism]], von Luca Cardelli und Peter Wegner.

Beim der ersten Form des Polymorphismus, dem *Polymorphismus durch Inklusion* setzen wir unsere denotationelle Brille auf und betrachten die zwei Typen S und T deren Kompatibilität zur Frage steht.
Beide dieser Typen spannen eine Menge von Objekten auf, indem sie ein Prädikate über die Zugehörigkeit zur Menge angeben.
Alle Elemente dieser Mengen sollten sich so Verhalten wie ein T, respektive ein S. Überschneiden sich jetzt die Mengen, so gibt es Objekte, die sich sowohl wie ein T, als auch wie ein S verhalten; diese Objekte können wir also sicher substitutieren.
Ist die Menge S vollständig in der Menge T enthalten, so können wir nicht nur einzelne Objekte, sondern den gesamten Typen substituieren. Typ S ist ein *Subtyp* von Typ T.

Das erste Beispiel für so einen Polymorphismus durch Inklusion sind *Subranges*. Dies sind abgeleitete numerische Typen, die den Wertebereich des orginalen Typen weiter einschränken. So ist jedes Element des Typen ~percent_t~ auch ein ~integer~. Das bedeutet, dass man diese Prozentzahlen ohne Probleme dort einsetzen kann, wo eine Ganzzahl erwartet wird.

Das umgekehrte gilt im Übrigen nicht unbedingt:
Addiert man mittels der ~integer~-Addition eine 1 auf die Prozentzahl 100, so ist das Ergebnis ganz sicher nicht mehr vom Typ ~percent_t~ abgedeckt.
Daraus können wir verallgemeinert lernen, weil wir ein Gegenbeispiel gefunden haben, dass Typkompatibilität, im Gegensatz zur Typäquivalenz, *nicht reflexiv* ist.

Die wohl bekannteste Form des Inklusionspolymorphismus ist die Vererbung zwischen Strukturtypen, wie sie in Objekt-Orientierten Sprachen vorkommt (~:public Base~) intentional an, dass ~Derived~ ein Subtyp von ~Base~ sein soll.
Aus dieser Intention, ergibt sich dann alles weitere in den Vererbungsmechanismen:
Um wenigstens die grundlegenste Art der Kompatibilität, nämlich Subtituierbarkeit im Speicherlayout zu erreichen, erbt die abgeleitete Struktur alle Elemente der Basisstruktur.
Weiterhin sorgt der Übersetzer dann dafür, dass die geerbten Strukturelmente an den gleichen Offsets, vom Beginn der Struktur her, zu finden sind.
Um Typkompatibilität auf der Ebene der Abstraktionen zu erreichen, erbt der abgeleitete Typ alle Interfaceoperationen, die der Elterntyp aufweißt.
Beides, Strukturkompatibilität und Interfacekompatibilität, sind direkte Folgen unseres Intentionalen Statements:
~Derived~ ein Subtyp von ~Base~ werden.

Am gezeigten C++ Beispiel kann man die Kompatibilität im Speicherlayout relativ direkt am Assembler ablesen.
Die Funktion ~getX()~, die sowohl mit Base als auch mit Derived Objekten aufgerufen werden kann, extrahiert das Strukturelement mit dem Namen ~x~ aus dem Objekt.
Dazu dereferenziert es den übergebenen Zeiger (~a0~) und schlägt ein Offset von 0 auf (~0(a0)~), da das Feld ~x~ ganz vorne in Base und Derived Objekten gespeichert wird.

Alle weiteren Regeln, welche Klasse was überschreiben darf, wann welche Felder, für wen, sicher sind, dass sind Sprachspezifka, die allerdings an dem grundlegenden Konzept von Vererbung nichts ändern: Wir, die Programmierer, wünschen uns dass ein Typ ein Subtyp eines anderen wird. Es ist dann die Aufgabe der Sprache und des Übersetzers alles notwendige zu tun, damit die daraus folgende Substituierbarkeit gewährleistet wird.

#+begin_src latex
  \begin{frame}[fragile]{Parametrisch: Generische Typen}
    \textbf{Bisher:} Alle Typkonstruktoren waren vorgegeben (\typeinline{record()}, \typeinline{map()})
    \medskip

    \bi
    \ii Parametrischer Polymorphismus erlaubt eigene Konstruktoren {
      \bi
      \ii Erinnerung: Konstruktoren sind Typ$^n$$\rightarrow$Typ Funktionen: \siginline{map}{$T \times T$}{$T$}
      \ii Wir führen Typvariablen in der Sprache ein um Typausdrücke zu \enquote{speichern}.
      \ii Trivialste Sicht: Eigene Typkonstruktoren sind Aliase:\\[1ex]{

        \begin{columns}
          \begin{column}{0.49\textwidth}
            \begin{code}[tag=Java]
              \begin{java}
                public class Pair<A> {
                  public A f;
                  public A s;
                }
              \end{java}
            \end{code}
          \end{column}\hfill
          \begin{column}{0.49\textwidth}
            \typeinline{Pair(A) := record(("f", A), ("s", A))}\\[1ex]
            \typeinline{type IntPair \btDefTab = Pair(int)}\\[-0.22ex]
            \hspace{4.2em}\typeinline{= record(("a", int"), ("b", int))}
          \end{column}
        \end{columns}

      }
      \ei
    }\bigskip
    \ii<2-> Mit eigenen Konstruktoren lässt sich Schreibarbeit sparen.{
      \begin{columns}
        \begin{column}{0.49\textwidth}\lstset{style=CPP,basicstyle=\ttfamily\scriptsize}
          \bi
          \ii \codeinline{class intLst { int v; intLst* n }}
          \ii \codeinline{class charLst { char v; charLst* n }}
          \ii \codeinline{class boolLst { bool v; boolLst* N }}
          \ei
        \end{column}\hfill
        \begin{column}{0.49\textwidth}
          \begin{code}[tag=C++]
            \begin{CPP}[basicstyle=\ttfamily\scriptsize]
              template<typename T>
              class List<T> {
                T        v;
                List<T>* n;
              };
            \end{CPP}
          \end{code}
        \end{column}
      \end{columns}
    }

    \ei
  \end{frame}

  \begin{frame}{Parametrisch: Typkonstruktoren werden selbst Typen}
    \begin{btBlock}{Generische Typen als First-Class Citizens}
      Die Stärke von parametrischem Polymorphismus ist, dass generische Typen nicht nur als Aliase sind, \ALERT{sondern} vollwertige Typen.
    \end{btBlock}
    \medskip

    \bi
    \ii Variablen, Parameter und Rückgabewerte können generisch Typ haben.{
      \bi
      \ii Listenlängen sind unabhängig vom Elementtyp: \siginline{length}{List[N]}{int}
      \ii Mehrfach auftrendende Typvariablen, propagieren Typen zur rechten Seite:\\
      \siginline{concat}{List[N] $\times$ List[N]}{List[N]}
      \ei
    }\medskip
    \ii Alle \textbf{konkreten Instanzen} sind komptatibel zum generischen Typ{
      \bi
      \ii Im Gegensatz zu Vererbung gibt es (potentiell) unendlich viele Instanzen.
      \ii \typeinline{Pair(int)}, \typeinline{Pair(bool)} sind kompatibel mit \typeinline{Pair(A)}.
      \ii Wie die einzelnen Instanzen zueinander stehen ist deutlich schwieriger.
      \ei
    }
    \ei
  \end{frame}
  #+end_src

Die zweite Form des universellen Polymorphismus ist der *parametrische Polymorphismus*. Der Grundgedanke hierbei ist es, dem Benutzer die Möglichkeit zu geben eigene Typkonstruktoren zu definieren und Typkonstruktoren, ganz allgemein, zu First-Class Citizens des Typssystems zu machen. Letzteres bedeutet, dass ein Typkonstrukor überall da stehen können soll, wo wir auch einen Typen hinschreiben können.

Zunächst aber führen wir *generische Typen* ein, die Typkonstruktoren darstellen, die der Benutzer selbst definieren kann.
Dazu führen wir *Typvariablen* auf Sprachebene ein, welche die Argumente für unsere selbst-definierten Typkonstruktoren sind.
Gewissermaßen als Funktionsrumpf des generischen Typen, erlauben wir es dem benutzer einen unvollständigen Typausdruck zu schreiben, der neben den echten Typen auch Typvariablen enthalten kann.
Instanziieren wir unseren generischen Typen, so werden die übergebenen Argumenttypen an die Typvariablen gebunden, im unvollständigem Typausdruck ersetzt, und der, nun valide Typausdruck, wird zurück gegeben.
Der generische Typ ist also eine Art von Schabole oder /Template/ auf ebene der Typausdrücke.

Im Java Beispiel lässt sich der beschrieben Mechanismus sehr gut sehen. Dort heißen generische Typen sogar /Generics/. Wir definieren hier einen Typkonstruktor mit dem Namen ~Pair~ der eine Typvariable ~A~ als Argument bekommt. Diese Typvariable kommt im Rumpf des Konstruktors, der einen Strukturtyp erzeugt, zweimal vor um zwei Strukturelmente zu typisieren. Dieser Konstruktor erzeugt also Typen, die homogen-getypte (beide Elemente haben den gleichen Typ) Paare bilden.

Wie wir im C++ Beispiel, wo generische Typen ~templates~ heißen, sehen, können wir eine Menge an Schreibarbeit durch die Verwendung von Templates sparen.
Wir müssen in unserem Program nur jedes vorkommen von ~intList~ durch ~List<int>~ und jedes Vorkommen von ~charList~ durch ~List<char>~ ersetzen. Dies spart eine Menge an sich immer wiederholdenden Typdefinitionen.

Ein weiterer Vorteil von generischen Typen sehen wir am Typen ~boolList~:
Dieser sieht beinahe so aus, wie die anderen beiden Typen, allerdings ist das Feld hier anders geschrieben.
Dies kann durch Unachtsamkeit oder Absicht geschehen sein, jedenfalls wird es beim Benutzer der ~boolList~ einiges an Frustration erzeugen.
Bei unserem Template ist die Sache anders:
Da wir immer die gleiche Schablone verwenden um Listentypen zu erzeugen, haben diese auch immer die gleichen Felder (und Operationen) und wir können die Erwartungen des Benutzers an ein einheitliches Interface aller Listen erfüllen.
Wenn wir diesem Argument genauer zuhören, dann hören wir schon den Polymorphismus durchklingen:
Alle Typen die durch den ~List<T>~ Konstruktor erzeugt wurden, haben gemeinsam, dass ihre Felder gleich heißen und in der gleichen Reihenfolge auftreten; nur die Feldtypen können unterschiedlich sein.

Darauf aufbauend können wir nun verstehen, wie parametrisches Polymorphismus funktioniert:
Wir heben die Unterscheidung zwischen Typen und Typkonstruktoren auf, und erlauben es Typkonstruktoren dort zu verwenden wo ein Typ stehen müsste.
Dies erlaubt es, dass generische Typen an Argumenten oder an Variablen auftreten können.
Damit können wir zum Beispiel die Funktion ~length(List[N])~ definieren, die auf jeglicher Liste, unabhängig vom Elementtyp, die Länge bestimmen kann.

Bekommt eine Funktion einen generischen Typen als Argument, so nennen wir sie *generische Funktion*.
Wenn wir bei diesen generischen Funktionen nach dem Funktionstyp fragen, so sehen wir, dass auch diese selbst generischer Typen sein muss.
So brauchen wir für den Funktionstyp von ~length()~ den Typkonstruktor ~type lengthType(N) = func(int, List(N))~.

Daraus folgt auch, dass die selbe Typvariable in den Signaturen von generischen Funktionen mehrfach auftreten kann und so ein Kopplung zwischen Argumenttypen und Rückgabetyp enstehen kann.
Dies wird gut am Beispiel von ~concat()~ deutlich:
~type concatType(N) = func(List(N), List(N), List(N))~.
Durch diese Kopplung können, wenn wir generische Funktionen hintereinander schalten um neue generische Funktionen zu erzeugen.
So hätte die Funktionskomposition beider Funktionen (~length(concat(x, y))~) den Typen ~func(int, List[T], List[T])~.
Diese Komposition von generischen Funktionen zu komplexeren generischen Funktionen ist der Kern von funktionaler Programmierung.
Wir werden diesem Thema in einem dedizierten Kapitel zu diesem Programmierparadigma noch genauer nachgehen.

 #+begin_src latex
  \bgroup
  \def\codebox#1{\Colorbox{codecolor}{\scriptsize #1}}
  \begin{frame}<handout:1-2>{Instanztypen: Covarianz, Contravarianz, und Invarianz}
    Bei der Kombination von Subtyping und parametrischen Polymorphismus können die Instanztypen \codebox{K[N]} unterschiedlich kompatibel sein:\\[1ex]

    \bi
    \ii \structure{Kovarianz}: Kompatibilität läuft entlang der Spezialisierungsrichtung{
      \bi
      \ii Möglich, wenn \codebox{K[N]} nur Quelle für Instanzen von \codebox{N} ist.
      \ii \codebox{Baker[Cake]} ist Subtyp von \codebox{Baker[Bread]}.\tikzmark{x}
      \ii Jedoch: \codebox{Baker[Bread]} ist inkompatibel mit \siginline{eatAll}{Baker[Cake]}{$\bot$}
      \ei
    }\bigskip
    \ii<2-|handout:2> \structure{Kontravarianz}: Kompatibilität läuft entgegen der Spezialisierung{
      \bi
      \ii Möglich, wenn der \codebox{K[N]} nur Senke für Instanzen von \codebox{N} ist.
      \ii \codebox{Customer[Bread]} ist Subtyp von \codebox{Customer[Cake]}.
      \ii Jedoch: \codebox{Customer[Cake]} ist inkompatibel mit \siginline{feed}{Customer[Bread]}{$\bot$}
      \ei
    }\bigskip
    \ii<3-|handout:2> \structure{Invarianz}: Instanztypen sind inkompatibel zueinander{
      \bi
      \ii Fallback, wenn \codebox{K[N]} sowohl Quelle als auch Senke sind.
      \ii Alle Instanzen von (veränderbaren) \codebox{Tüte[N]} sind inkompatibel zueinander.
      \ei
    }
    \ei
    \OrangeBox[putat={(4.5cm, 5cm)},visible on=<1|handout:1>,align=left]{\footnotesize
      \codebox{Cake} ist ein spezielles (erbt von) \codebox{Bread}.\\
      \codebox{Baker[T]} bäckt Gebäck vom Typ T.\\
      \codebox{Customer[T]} kauft Gebäck vom Typ T.
    }
  \end{frame}
  \egroup
#+end_src

Wir haben gesagt, dass alle Instanzen eines Typkonstruktors kompatibel zum Konstruktor selbst sind (~List[int]~ ist kompatibel zu ~List[N]~).
Allerdings ist es deutlich schwieriger zu sagen, wie es um die Typkompatibilität der einzelnen Instanzen steht.
Ist zum Beispiel ~List[int]~ kompatibel zu ~List[float]~?
Dies hängt maßgeblich davon ab, wie die übergebenen Typen zueinander stehen.
Sind diese in keinster Weise kompatibel, so können wir auch davon ausgehen, dass die daraus instanziierten Listentypen kompatibel zueinander sind. Eine ~List[Pferd]~ und eine ~List[Brötchen]~ sind sicherlich nicht durcheinander substituierbar. Beim einen kommen Pferde, beim anderen mal Brötchen raus; beide haben nichts miteinander gemein.



#+begin_src latex
  \begin{frame}[fragile]{Type Traits: \enquote{Typen von Typparametern}}
    \OrangeBox{\codebox{Baker[Car]} ist sinnlos: Autos backt man nicht bei 180 Grad Umluft.}
    \bigskip

    \bi
    \ii Generische Typen können Einschränkungen für ihre Parameter haben.{
      \bi
      \ii Meta-Typen  kann  strukturell, abstraktional und denotional auffassen.
      \ii \structure{Strukturell}:   Typparameter muss bestimmtes Feld haben.
      \ii \structure{Abstraktional}: Typparameter muss ein bestimmtes Interface haben.
      \ii \structure{Denotional}:    Typparameter muss Subtyp von bestimmter Klasse sein.
      \ei
    }\bigskip

    \begin{columns}<2->[t]
      \begin{column}{0.49\textwidth}
        \textbf{Beispiel}: Generics bei Java

        \begin{code}
          \begin{java}[style=smaller]
            class Baker<T extends Bread> {
              void bake(T b) {
                oven.heat(b.degrees());
              }
            }
          \end{java}
        \end{code}

        Ein \codebox{Baker} kann nur\\ Unterklassen von
        \codebox{Bread} backen.
      \end{column}\hfill
      \begin{column}{0.49\textwidth}
        \textbf{Beispiel}: Type Traits in Rust

        \begin{code}[]
          \begin{rust}
            pub trait Bakable {
              fn degrees(&self) -> f64;
            }

            impl Bakable for Cake {
              fn degrees(&self) -> f64 {
                return 180;
              }
            }
            fn bake<T: Bakable>(b: T);
          \end{rust}
        \end{code}
      \end{column}
    \end{columns}
    \ei
  \end{frame}
#+end_src

* Typsysteme in Programmiersprachen
:PROPERTIES:
:CUSTOM_ID: 03-typesystems
:END:
#+begin_src  latex
  \begin{frame}{Typsysteme: Verwendung von Typen in der Sprache}
    \bi
    \ii Das \STRUCTURE{Typesystem} einer Sprache, beschreibt wie diese Typen verwendet.{
      \bi
      \ii Welche eingebauten Typen und Typkonstruktoren stehen bereit?
      \ii Wie ist die Äquivalenz und Kompatibilität von Typen definiert?
      \ii Ist das Typsystem monomorph oder enthält es Polymorphismus?
      \ei
    }\bigskip
    \ii Darüber hinaus haben Typsysteme weitere charakteristische Eigenschaften:{
      \bi
      \ii \STRUCTURE{Typsicherheit}:   Kann ich das Typssytem (unbemerkt) umgehen?
      \ii \STRUCTURE{Dynamik}:         Zu welchem Zeitpunkt werden die Typen geprüft?
      \ii \STRUCTURE{Automatisierung}: Wieviel Arbeit nimmt der Übersetzer uns ab?
      \ei
    }
    \ei

    \begin{btBlock}<2->{Handreichung für den effektiven Neuling}
      Um eine Sprache effektiv zu erlernen, muss ich das Typsystem der neuen Programmiersprache prägnant beschreiben und mit bereits bekannten Sprachen vergleichen können.
    \end{btBlock}

  \end{frame}

  \begin{frame}[fragile]{Typsysteme: Starke vs. Schwache Typisierung}
    \begin{center}\SAMPLE{\Large
      "Wie strikt forciert die Sprache ihr Typsystem?"
    }\end{center}

    \bi
    \ii Das Typsystem einer Programmiersprache heisst stark typisiert, wenn: {
      \be
      \ii Es gibt unterschiedliche Typen.
      \ii Implizite (automatische) Konvertierung nur zwischen ähnlichen Typen.
      \ii Explizite Typekonvertierungen sind der Regelfall.
      \ee
    }\bigskip
    \ii Python ist ein Beispiel für eine stärker typisierten Sprache. {
      \bi
      \ii Jedes Objekt hat genau einen Typ, der bei der Erstellung festgelegt wird.
      \ii Wenige implizite Konvertierung. Zum Beispiel: \texttt{int}$\rightarrow$\texttt{float}: \codeinline{1+4.5} $\Rightarrow 5.5$
      \ii Konvertierungen explizit sichtbar: \codeinline{int("23")} $\Rightarrow 23$, \codeinline{str([1,2])} $\Rightarrow$ \texttt{"[1, 2]"}
      \ei
    }\medskip
    \ii Beispiele für schwache Typisierung{
      \bi
      \ii TCL: Alles ist ein String. Jede Operation interpretiert den String anders.
      \ii PHP ($<7$): Implizite Konvertierung von \texttt{str}$\rightarrow$\texttt{int}: \codeinline{"23"+4}$\Rightarrow$ 27
      \ii C: Arrays werden, falls nötig, zu einem Pointer auf ihr erstes Element.
      \ei
    }
    \ei
  \end{frame}

  \begin{frame}[t,fragile]{Typsysteme: Statische vs. Dynamische Typisierung}
    \begin{center}\SAMPLE{\Large
      "Werden Typen statisch im Quellcode annotiert?"
    }\end{center}

    \bi
    \ii Statische Typisierung: C, C++, Rust, Java, Haskell,\ldots{
      \bi
      \ii Bei jeder Definition/Deklaration wird ein statischer Typ festgelegt.
      \ii Variablen können niemals ein Objekt falschen Typs beinhalten.
      \ii Variablen und Funktionen bekommen einen Typ: \codeinline{pair<int, int> foo}{
        \begin{center}
          \includegraphics[page=2,width=0.7\textwidth]{fig/03-static-types}
        \end{center}
      }
      \ei
    }\medskip
    \ii Dynamische Typisierung: Python, PHP, JavaScript, Lisp, \ldots {
      \bi
      \ii Variablen haben keine fest assoziierten Typen.
      \ii Nur die Objekte, die in den Variablen \enquote{leben}, haben eine Typ.
      \ei
      \begin{center}
        \includegraphics[page=1,width=0.7\textwidth]{fig/03-static-types}
      \end{center}
    }
    \ei
    \begin{overlaybox}<2>[draw=srared,ultra thick,drop shadow,inner sep=1em]
      Die Frage nach \enquote{Statisch} oder \enquote{Dynamisch} ist eine der wichtigsten Fragen bei Programmiersprachen und beim Übersetzerbau!\\[1ex]
      \begin{columns}
        \begin{column}{0.49\textwidth}
          \STRUCTURE{Statisch}
          \bii
          \ii Vor der Laufzeit.
          \ii Im Übersetzer.
          \ii Im Quellcode notiert.
          \ii Entscheidung ohne Ausführung.
          \ii Später Kostenlos.
          \eii
        \end{column}\hfill
        \begin{column}{0.49\textwidth}
          \STRUCTURE{Dynamisch}
          \bii
          \ii Während Laufzeit.
          \ii In der virtuellen Maschine.
          \ii Im Maschinenezustand.
          \ii Enscheidung bei Auführung.
          \ii Ausführungskosten.
          \eii
        \end{column}
      \end{columns}

    \end{overlaybox}
  \end{frame}

  \begin{frame}[fragile]{Typsysteme: Explizite vs. Implizite Typisierung}
      \begin{center}\SAMPLE{\Large
      "Muss ich alle Typen wirklich hinschreiben?"
    }\end{center}

    \bi
    \ii Statische Typisierung erhöht die Menge an \emph{explizit} getippten Zeichen.{
      \begin{code}[tag=C++03]
        \begin{CPP}
          std::vector<int> vec;
          for (std::vector<int>::iterator it : vec) {...}
        \end{CPP}
      \end{code}
      \bi
      \ii Teilweise wäre der Datentyp aus dem Kontext heraus klar.
      \ii Beim Programmierer entsteht das Gefühl von Boilerplate:\\
      \enquote{Der Übersetzer weiß das doch eh! Warum muss ich das hinschreibeb?}
      \ei
    }\medskip
    \ii Implizite Typisierung und \textbf{Typinferenz} macht das Leben einfacher.{
        \begin{code}[tag=C++11]
        \begin{CPP}
          std::vector<int> vec;
          for (auto it : vec) {...}
        \end{CPP}
      \end{code}
      \bi
      \ii Der Übersetzer errechnet den Typen für \texttt{it} aus dem Kontext.
      \ii Fortgeschrittene Typinferenz mittels Unifikation möglich (später.)
      \ei
    }
    \ei
  \end{frame}
#+end_src

* Zusammenfassung

#+begin_src latex
  \begin{frame}{Zusammenfassung}
    FIXME
  \end{frame}
#+end_src
