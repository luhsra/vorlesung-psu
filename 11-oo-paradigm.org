#+TITLE: Programmiersprachen und Übersetzer
#+SUBTITLE: 11 - Das Objekt-Orientierte Programmierparadigma
#+SETUPFILE: setup.org
#+INCLUDE: export-prologue.org
#+PROPERTY: header-args:latex :tangle yes :noweb yes :tangle-macros yes :tangle-prologue topic :tangle-epilogue endtopic :exports none

#+NAME: topic
#+BEGIN_SRC latex :tangle no
\psuSectionStart{{{{property(ITEM)}}}}{{{{n(block)}}}}
#+END_SRC

#+NAME: endtopic
#+BEGIN_SRC latex :tangle no
\psuSectionStop{{{{property(ITEM)}}}}{{{{n(block,-)}}}}
#+END_SRC

* Gedanken zu dieser Vorlesung                                     :noexport:
- Was ist das Grundlegende Problem?
  - Softare ist Komplex => Kein Problem für die Maschiene
  - Software Complexity ist ein Problem für Menschen
  - Zum einen muss es in den Kopf eines einzigen Menschen passen.
  - Zum anderen braucht man eine gemeinsame Sprache mit seinen Mitentwicklern.

- Was ist ein Programmierparadigma?
  - https://www.info.ucl.ac.be/~pvr/VanRoyChapter.pdf
  - Paradigma: Eine Menge von zusammenhängenden Konzepten die miteinander harmonieren.This chapter is partly based on the book [50], familiarly known as CTM, which givesThis chapter is partly based on the book [50], familiarly known as CTM, which gives
  - Konzepte sind zu Paradigmen gruppiert.
  - Sprachen implementieren 1..N Paradigmen. Meistens mehrere
  - Die Paradigmen helfen dabei das Programm zu strukturieren.

- Das Imperative Paradigma
  - State + Procedure + Record
  - State: Benannter Zustand
  - Procedure:  Sequenzierung von mehreren Befehlen zu einem Ablauf
  - Record:     Strukturierte Objekte

  => Wie Dekonstruiert man damit ein großes Problem?

- Das Objekt-Orientierte Paradigma
  - Closures: Prozeduren mit teilweise aus dem Environment gebundenen Variablen
  - => Instantiierbare Namensräume mit Methoden sind Closures.

  - Was machen Leute damit?
    Sie Bilden die Strukturen der Realen Welt auf Objekte ab => User

    Design: Class Structure vs. Object Structure

    => Wie dekonstruiert man damit ein großes Problem?

  - Kritik an OO: Es gibt keine Algorithmen ohne Zustand

    The problem with object-oriented languages is they've got all this implicit environment that they carry around with them.
    You wanted a banana but what you got was a gorilla holding the banana and the entire jungle.



* Paradigmen und Komplexität
:PROPERTIES:
:CUSTOM_ID: 11-einleitung
:END:
#+begin_src latex
  \subtitle{{{{subtitle()}}}}
  \maketitleframe

  \begin{frame}{Wiederholung: Die semantische Lücke}
  \begin{columns}
    \begin{column}{0.30\textwidth}
      \begin{center}\small
        \includegraphics[width=1.5cm]{fig/01-problem}\\\relax
        [Problem]\\[1ex]
        \fbox{\parbox{0.8\textwidth}{\centering
            Hochsprache\\
            $\Uparrow$\\
            \structure{Semantische Lücke}\\
            $\Downarrow$\\
            CPU-Steuersignale
          }}\\[1ex]\relax
        [Ausführung]\\\relax
        \includegraphics[width=1.5cm]{fig/01-cpu}
      \end{center}
    \end{column}\hfill
    \begin{column}{0.65\textwidth}
      Mit unserem Übersetzer haben die semantische Lücke \advantage{überwunden}:

      \begin{center}
        Source $\rightarrow$ AST $\rightarrow$ IR $\rightarrow$ ASM $\rightarrow$ ELF
      \end{center}

      \bii
      \ii Beschreibung des Problems in Hochsprache
      \ii Schrittweises Absenken der Abstraktion
      \ii Schichten versprechen wohldefinierte Semantiken.
      \eii

      \bigskip
      \pause
      \ALERT{Aber:} \btSetTab Warum türmen wir überhaupt \\\btUseTab diese semantische Lücke auf?

      \bii
      \iida Lernkurve: Abstraktionen müssen gelernt werden.
      \iida Fehleranfällig: Übersetzer können Bugs haben
      \iida Abstraktionen erzeugen oft einen Overhead
      \eii

      \OrangeBox{Welchen Nutzen hat die semantische Lücke?}
    \end{column}
  \end{columns}
  \end{frame}

  \begin{frame}{Komplexität und Nicht-Determinismus}
    \bi
    \ii Große Systeme haben zwei Dimensionen, die das \structure{Verständnis} erschweren{%
      \bi
      \ii \structure{Komplexität}: Anzahl der interagierenden Elemente?
      \ii \structure{Nicht-Determinismus}: Wie vorhersagbar sind die Interaktionen?
      \ei
    }\bigskip
    \ii<2-> \textbf{Beispiel}: Das gesamte Universum {
      \bi
      \ii Viele Elemente (Atome), die  zufällig interagieren (Quantenmechanik)
      \ii Für das funktionieren des Universums ist das egal.
      \ii Für unser Verständnis vom Universum ein Problem.
      \ei
    }\bigskip
    \ii<3-> Ein großes Programm als ein großes System.{%
      \bi
      \ii Viele Elemente (Daten) interagieren miteinander (abhängige Operationen).
      \ii Für die Maschine egal. Operationen werden stumpf nacheinander ausgeführt.
      \ii \structure{Problem Menschen}: Da sie es nicht verstehen, können sie es nicht bauen.
      \ei
    }
    \ei
  \end{frame}

  \begin{frame}{Mensch vs. Maschine}
    \centering
    \btAnimation[height=8cm]{range=1-4:<1->}{fig/11-complexity}
  \end{frame}

  \begin{frame}{Konzepte, Paradigmen, Prinzipien}
    Damit wir Menschen \textbf{komplexe Systeme} bauen, verstehen und kommunizieren können, brauchen wir Abstraktionen und Strukturen.

    \bigskip

    \bi
    \ii Sprachen bieten Abstraktionen zum denken und kommunizieren{%
      \bi
      \ii \structure{Konzepte}: Welche Abstraktionen kann es überhaupt geben?\\[1ex]
         Beispiele: Records, Zustand, Prozeduren, Closures, Threads, Nachrichten\\[3ex]
      \ii \structure{Paradigmen}: Welche Abstraktionen nutze ich in Kombination?\\[1ex]
      Beispiel: Imperativ  = Records + Zustand + Sequenzierung + Prozeduren\\[3ex]
      \ii \structure{Prinzipien}: Wie nutze ich die Abstraktionen (ohne Knieschuss)?\\[1ex]
      Beispiel: Liskovsches Substitutionsprinzip\\
      \onslide<2>{$\Rightarrow$    Software Engineering}
      \ei
    }
    \ei
  \end{frame}


  \begin{frame}<handout:4>{Hierarchie der Begrifflichkeiten}
    \centering
    \btAnimation[width=0.7\textwidth]{range=1-4:<1->}{fig/11-principles}
  \medskip
    \bii
    \ii<2->  Paradigmen bündeln Konzepte zu einem konsiztenten Programmiermodell
    \ii<3-> Es gibt \ALERT<3->{viel mehr} Sprachen als Paradigmen
    \ii<4-> Die meisten Sprachen bedienen mehr als ein Paradigma.\\[1ex]
    Oft: Ein Paradigma für \structure{Grobstruktur} + Ein Paradigma für die \structure{Feinstruktur}
    \eii
  \end{frame}
#+end_src

In den letzten 10 Vorlesungseinheiten haben wir uns mit dem Thema Programmiersprachen und ihrer Übersetzung von zwei Seiten genähert.
Zum einen haben wir in vier Vorlesungen (Typen, Namen, Objekte, Operationen) einzelne Sprachkonzepte auf einem sehr kleinteiligen Niveau kennen gelernt.
Zum anderen haben wir uns mit den einzelnen Schritten der Übersetzung (Syntaxanalyse, Semantische Analyse, Zwischencodeerzeugung, Optimierung und Maschinencodeerzeugung) auseinander gesetzt.
In dieser und der nächsten Vorlesung wollen wir wieder einen Schritt zurück machen, und uns die grundsätzliche Frage stellen "Warum haben wir überhaupt Programmiersprachen?" und "Folgen einzelne Sprachen ähnlichen Paradigmen?".

Mit den verwendeten Sprachkonzepten erlauben Programmiersprachen es uns ein Problem auf einer abstraken Ebene und mit einem großen Abstand zu einer real-existierenden Maschine zu formulieren.
Dieser Abstnd ist die semantische Lücke und der Übersetzer (oder auch ein Interpreter) überbrücken diese Lücke auf automatisierte Art- und Weise.
Dabei stellt sich aber die Frage, warum wir diese semantische Lücke aufbauen, wenn wir dafür zusätzliche Werkzeuge brauchen um Sie wieder zu überbrücken.
Neben der Tatsache das Übersetzer leicht anfällig für Bugs sind, erzeugen komplexe Sprachkonstrukte eine Lernkurve, die von den  Entwicklern erst überwunden werden muss bevor diese effektiv und effizient arbeiten können.
Welchen nutzen hat es demnach die semantische Lücke aktiv auszuweiten und sogar eventuelle Overheads, die bei der Abbildung auf die Maschine entstehen, in Kauf zu nehmen?

Für die Maschine tun wir dies sicherlich nicht, da diese in allen Fällen das Programm gleich ausführt, egal wie groß die semantische Lücke zum Quellprogramm vorher war.
Für die Maschine brauchen die Daten auch keine Struktur, da auf der untersten Ebene einer Von-Neumann-Maschiene der Datenspeicher ein großes ~char~-Array ist und das Programm ein Array von Instruktionen.
Vielmehr müssen wir den Nutzen den semantischen Lücke bei den Entwicklern, insbesondere denen großer Softwaresysteme, suchen.

In großen Softwareprojekten erzeugt das Zusammenspiel von drei Aspekten eine besondere Qualität babylonischer Verwirrung bei den Entwicklern:
Eine große Menge von heterogenen Informationen (Objekte) wird von vielen Operationen verarbeitet, wobei einzelne Operationen in ihrer Ausführungen voneinander abhängig sein können{{{see(07-operation-dependencies,Abhängigkeiten zwischen Operationen)}}} und daher in einer gewissen Reihenfolge abgearbeitet werden.
Dieses komplexe Netz interagierender Elemente wird dabei nicht nur von einem einzelnen Entwickler orchestriert, sondern von einem oder mehreren Entwicklungsteams, die über die gesamte Erde, in unterschiedlichen Zeitzonen und mit unterschiedlichem kulturellen Hintergrund, verteilt an dem Programm arbeiten.
Und hier kommt das eigentliche Problem bei der Programmierung: **Wie können wir den Menschen das Verständnis und die Kommunikation von Programmcode erleichtern?**

Diese Aufgabe stellt sich als garnicht so leicht heraus.
Wollen wir zunächst einmal die beiden Prozessoren vergleichen:
Auf der einen Seite des Rings stehen die mechanischen Rechenanlagen (Computer), die eine große Menge an Speicher haben auf den sie mit großer Bandbreite uniform (jede Zugriff dauert in etwa gleich lange) zugreifen können.
Zusätzlich zu diesem perfekten Gedächtnis führen Maschinen in jedem Operationszyklus eine strikt definierte Aktion durch; ohne Gnade, ohne Zögern, ohne Fehler und ohne Müdigkeit, immer uniform.
Auf der anderen Seite befinden sich unsere Gehirne, die im direkten Vergleich nicht gut abschneiden:
Der Speicher eines Menschen ist begrenzt und nicht erweiterbar, Zugriffe dauern unterschiedlich lange (erinnern) und können verfälschte, oft nur assoziierte, Ergebnisse liefern.
Die Verarbeitung der abgerufenen Ergebnisse ist langsam, fehleranfällig, und nicht zu selten uneindeutig. 
Noch schlimmer wird es wenn zwei Menschen miteinander kommunizieren: Wo zwei identisch arbeitende Maschinen mit dem gleichen Programm ausstatten können, haben zwei Menschen niemals das gleiche Set an Assoziatione, was unweigerlich zu Missverständnissen führt. Außerdem hat der Kommunikationskanal nur eine sehr geringe Datenrate, was im krassen Gegensatz elektrischen oder opto-elektrischen Computernetzen zu sehen ist.
Das eigentliche Problem ist also nicht die Maschine, sondern der Mensch, der diese, in Gemeinschaft mit anderen, versucht zu instruieren.

Um mit der Komplexität von Systemen umzugehen, haben wir ein unfassbar nützliches Werkzeug entwickelt:
**die Abstraktion**.
Durch die Abstraktion strukturieren wir große Probleme und Lösungen in immer kleiner werdende Partikulärprobleme und -lösungen.
Dabei muss ein Mensch nicht die gesamte Lösung für ein Problem verstehen, sondern kann auf einer Abstraktionsstufe stoppen und die Lösung aus Partikulärlösungen der nächst niedrigeren Stufe komponieren.
Um das etwas Anschaulicher zu gestelten:
Die Abstraktion Record bietet uns die Möglichkeit viele Objekte mit gleicher Struktur zu erstellen und auf die einzelnen Felder zuzugreifen.
Dabei müssen wir uns (meist) keine Gedanken machen, wie diese Felder in den Speicher gelegt werden oder wie die Offsets berechnet werden.
Durch die Verwendung der Abstraktion können wir das Datenlayout und die Addressberechnungen dem Übersetzer überlassen und den Programmcode für einen Algorithmus auf einem deutlich abstrakteren Niveau formulieren.
Am Ende arbeitet das Programm ebenso, als hätten wir die Adressberechnungen direkt mit dem Algorithmus vermischt, aber durch die Verwendung der Abstraktion wird das Programm deutlich verständlicher und für andere leichter zu verstehen.

Im Rahmen von Programmiersprachen können wir die angebotenen Abstraktionen mit Begrifflichkeiten fassen:
Auf der kleinteiligsten Ebene finden wir die **Konzepte** einer Sprache.
Jedes Konzept ist eine Abstraktion die von der Sprache bereit gestellt wird.
So ist die Möglichkeit einen Record Datentypen anstatt manuelle Adressberechnungen zu verwenden ebenso ein Sprachkonzept, wie die Möglichkeit Prozeduren zu erstellen ein Konzept ist.
Aber auch höhere Abstraktionen, wie Threads (Ausführungsfäden) oder Nachrichten, können Sprachkonzepte darstellen, wenn diese direkt in der Spezifikation der Sprache angeboten werden.

Aus einer Kombination von Konzepten kann man ein **Paradigma** formen.
Ein Paradigma ist eine aufeinander abgestimmte Menge von Konzepten, die man in einer Sprache verwenden kann.
Ein Paradigma stellt quasi einen vorgefertigten Werkzeugkasten an Konzepten dar aus dem man sich bedienen kann um ein konkretes Problem zu lösen.
Als Beispiel kann hier das imperative Paradigma dienen, welches es erlaubt Daten strukturiert als veränderlichen Zustand abzulegen und durch sequentiell abgearbeitete Prozeduren zu verarbeiten.
Andere Paradigmen können die Menge der angebotenen Konzepte vergrößern (Das objektorientierte Paradigma), aber auch bewusst einschränken (Das funktionale Paradigma).

Haben wir einmal ein Paradigma (=Werkzeugkasten) definiert und wird es von einer Sprache angeboten, stellt sich noch die Frage, wie wir die enthaltenen Konzepte (=Werkzeuge) kombinieren können, ohne uns beständig in den Fuss zu schießen.
Solche "best practices" nennen wir **Prinzipien** und sie sind Thema des Software Engineerings. Dort lernen Sie, wie Sie Objektorientierung richtig verwenden und sich, zum Beispiel, bei Vererbung an das [[https://de.wikipedia.org/wiki/Liskovsches_Substitutionsprinzip][Liskovsche Substitutionsprinzip]] halten.
In dieser Vorlesung wollen wir uns nicht weiter mit Prinzipien auseinander setzen, sonder bei den Konzepten und, in dieser und der nächsten Vorlesung, bei den Paradigmen bleiben.

Grundlegend festzustellen ist, dass es deutlich mehr Programmiersprachen als Paradigmen gibt.
So gibt es viele Sprachen, die das objektorientierte Paradigma, teils in unterschiedlichen Geschmacksrichtungen, aber häufig mit großer Ähnlichkeit implementieren.
Allerdings ist zu beobachten, dass moderne Sprachen sich nicht nur auf die Implementierung eines Paradigmas beschränken, wie das bei frühen Sprachen der Fall war, sondern oft mehrere Paradigmen beinhalten. Damit werden diese zu einer **Multi-Paradigmensprache** und bieten gewissermaßen mehrere Werkzeugkoffer an, aus denen sich die Entwickler bei der Lösung der gestellten Probleme bedienen können. Eine Übersicht und eine detaillierte Diskussion von Programmierparadigmen finden Sie im Kapitel [[https://www.info.ucl.ac.be/~pvr/VanRoyChapter.pdf]["Programming Paradigms for Dummies: What Every Programmer Should Know"]] von Peter Van Roy. Insbesondere die Taxonomie auf Seite 13 (Figure 2) gibt einen großen Überblick über das Thema Programmierparadigmen und wie diese miteinander im Zusammenhang stehen.

* Das imperative Programmierparadigma
:PROPERTIES:
:CUSTOM_ID: 11-imperative-paradigma
:END:


In diesem Unterkapitel widmen wir uns dem imperativen Paradigma dem grundlegendsten Paradigma das wir für die Entwicklung von Programmen verwenden können.
Dabei zähle ich das Sprachkonzept der "Prozeduren" zum imperativen Paradigma hinzu und mache keine gesonderte Unterscheidung zwischen rein imperativem Programmieren (ohne Prozeduren) und einem prozeduralen Paradigma (mit Prozeduren), da diese Unterscheidung seit dem Aufkommen strukturierter Programmierung in den 60ern nicht mehr von tatsächlicher Relevanz ist.
Aber seien Sie gewarnt, Sie können da draußen auf Menschen treffen, die diese Unterscheidung machen und pedantisch auf ihr beharren.

#+begin_src latex
  \dividerframe{Das Imperative Paradigma}

  \begin{frame}{In the Beginning,\ldots}
    \btAnimation[width=\textwidth]{range=1-2:<1->}{fig/11-organization}

    \medskip
    \bi
    \ii   \ldots all data was unstructured and all operations were floating.{
      \bi
      \ii<2->[+=] \structure{Records}: Daten werden zu Datenstrukturen zusammengefasst.
      \ii<2->[+=]\structure{Sequenzierung}: Befehle nacheinander ausführen. Ergebnisse weitergegeben.
      \ei
    }\medskip
    \ii<2-> Beispiel: Reverse Polish Notation (wie in PostFix) {
      \bi
      \ii Von Links nach rechts ausführen, Impliziter Stack für die Berechnung
      \ii \texttt{1 3 + 5 4 - *} == \texttt{(1 + 3) * (5 - 4)}
      \ei
    }
    \ei
  \end{frame}
#+end_src

Um das imperative Paradigma zu charakterisieren werden wir die einzelnen Sprachkonzepte beleuchten, die es ausmachen.
Diese Konzepte haben Sie alle, in dieser oder in anderen Veranstaltungen, bereits kennen gelernt, jedoch vielleicht bisher nicht als voneinander abtrennbar wahrgenommen. Daher wollen wir die einzelnen Konzepte nun durchgehen und Sie können bei jedem Konzept fragen, ob es wirklich notwendig für eine Sprache ist, und wie die Sprache aussähe, wenn es dieses Konzept nicht gäbe. Auf diese Weise bekommen Sie ein besseres Gefühl für den Designspace in dem sich die Sprachentwickler bewegen, wenn sie ein neues Paradigma entwickeln.

Zunächst, schauen wir uns den Urzustand einer (virtuellen) Maschine an, die nur aus Daten und Operationen besteht.
Stellen Sie sich vor, beides würde frei im Raum herum schweben um muss erst noch strukturiert durch Konzepte abstrahiert werden.
Das erste Konzept, was in allen Paradigmen gemein ist, ist **Strukturiertheit der Daten**.
Anstelle eines großen Sees aus Zahlen (der ganze Speicher als ein ~char~-Array) wollen wir einzelne Objekte haben, die eine innere Struktur haben.
Ausgedrückt wird dieses Konzept, zum Beispiel, durch Record-Datentypen. Damit können wir einzelne Objekte und deren innere Struktur deklarieren.
Ohne diese Strukturiertheit kann es keine abstrakte Programmiersprache geben, da man keine semantische Verbindung mehrere Informationshäppchen formulieren kann.

Als Beispiel für Sprachen, die ausschließlich diese Strukturiertheit, und sonst nichts weiter, bieten, kann man Auszeichnungssprachen wie XML bezeichnen.
Dort gibt es nur Objekte und deren hierarchisch geschachtelte Struktur, aber keiner Operationen.
Daher ist XML als Sprache nicht Turing-vollständig und daher nicht zu programmieren geeignet. Dennoch bietet XML nützliche Abstraktionen, um Probleme zu abstrahieren.

Als zweites Konzept des imperativen Programmierens kann die **Sequentielle Ausführung von Operationen** gelten.
Die Idee, dass die Entwickler angeben, in welcher konkreten Reihenfolge einzelne Operationen mit welchen Daten ausgeführt werden, gibt uns die Möglichkeit ein Problem in viele Einzelschritte zu zerlegen. Jede Operation ist die Abstraktion ihrer elektronischen Implementierung, und die Aneinanderreihung von Operationen ist die Verwendung dieser Abstraktion.
Durch die Sequenzierung geben die Entwickler eine strikte Reihenfolge vor, wie Operationen ausgeführt werden sollen und wählen so selbst eine Linearisierung der Operationsabhängigkeiten. Fragen Sie sich: Wie sähe ein Sprache aus, bei denen Abhängigkeiten zwischen Operationen ganz frei, wie in einem Abhängigkeitsgraphen, formuliert werden können. Und warum wäre das für die Übersichtlichkeit, einem unseren primären Ziel bei der Sprachentwicklung, nicht nützlich.

#+begin_src latex
  \begin{frame}{Kontrollfluss und Prozeduren}
    \begin{columns}
      \begin{column}{0.35\textwidth}
        \btAnimation[width=\textwidth]{range=1-3:<1->}{fig/11-prozeduren}
      \end{column}\hfill
      \begin{column}{0.58\textwidth}
        \bi
        \ii<2-> Komplexe Abläufe als Kontrollfluss {
          \bi
          \ii[+=] \structure{Selektion}: Endlich können wir eine Operation auch mal auslassen.\\[1ex]
          \ii[+=] \structure{Iteration}: Endlich können wir eine Operation mehrfach ausführen ohne sie doppelt zu notieren.
          \ei
        }\medskip
        \ii<3-> \textbf{Wiederverwendung} durch \structure{Prozeduren} {
          \bi
          \ii Operationen werden ein Verbund und bekommen einen Namen.
          \ii Parameter und Rückgabewerte
          \ii[+=] \structure{Invokation}: Starte die Ausführung des Operationsverbundes.
          \ei
        }
        \ei
        \bigskip
        \onslide<3->{
          \scriptsize (Beinahe) Synonyme: Funktionen, Prozedur, Routinen
        }
      \end{column}
    \end{columns}
  \end{frame}

  \begin{frame}[fragile]{Entwurfsprinzip: Prozedurale Abstraktion}
    \bi
    \ii Prozeduren sind eine \ALERT{technische Einrichtung} der Sprache{
      \bi
      \ii Gibt uns das grundlegende Prinzip der Code-Wiederverwendung.
      \ii Die Sprache schreibt \textbf{nicht} vor, wie diese zu Verwenden sind.
      \begin{columns}
        \hfill
        \begin{column}{0.4\textwidth}
          \begin{code}[]
            \begin{py}
              def step3():
                 step1()
                 doIntermediateStep()
                 step2()
            \end{py}
          \end{code}        
        \end{column}\hfill\mbox{}
      \end{columns}
      \ei
    }\bigskip
    \ii<2-> \structure{Prozedurale Abstraktion}: Zerlegung des Problems als in Teilprobleme{
      \bi
      \ii Aufteilung des Codes anhand \textbf{problemspezifischer Grenzen}
      \ii Eine Funktionalität $\rightarrow$ Eine Prozedur
      \ii Implementierung der Funktionalität wird hinter dem Funktionsnamen versteckt und kann problemlos ausgetauscht werden (z.B. Bugfix).
      \ei
      \begin{code}[]
        \begin{CPP}
          char *strstr(const char *haystack, const char* needle);
        \end{CPP}
      \end{code}
    }
    \ei
  \end{frame}
#+end_src

In die gleiche Richtung wie die Sequenzierung stoßen die Konzepte der **generellen Kontrollflusskonstrukte**, die es uns ebenfalls Erlauben den Ausführungsstrom zu beeinflussen.
Dabei haben wir die Konzepte **Selektion** und **Iteration** für den Kontrollfluss im kleinen, und **Prozeduren** und **Invokation** im Großen kennen gelernt. 

Durch kleinteiligen Konzepte sind wir in der Lage komplexe Abläufe zu strukturieren und Abhängig von den Eingabedaten unterschiedliche Kontrollflüsse auszuführen. Dabei gibt es diese generellen Konzepte in unterschiedlichen Abstraktiosniveau: Eine "Schleife" mit ~if~ und ~goto~ hat sicherlich ein geringeres Abstraktionsniveau, als eine logisch-kontrollierte Schleife, welche wiederum weniger abstrakt ist als eine Aufzählungsschleife über eine dynamisch berechnete Sequenz von Objekten.
Stellen Sie sich vor, welchen enormen technischen Fortschritt es dargestellt hat eine Maschine zu bauen, die ihre selbst-berechneten Ergebnisse verwendet um ihre zukünftige Operationsweise zu beeinflussen. Einfach der Hammer, im Vergleich zum [[https://en.wikipedia.org/wiki/Centrifugal_governor][Fliehkraftdrehregler]] unendlich flexibler.

Ebenfalls bedeutend sind die **Prozeduren**, welche die parametrisierbare Wiederverwendung von Code erlauben.
Eine Menge von Operationen, die zum Beispiel durch Sequenzierung, Selektion und Iteration, strukturiert wurden, können durch eine Prozedur wiederverwendbar gemacht werden.
Durch die Möglichkeit die lokalen Variablen innerhalb einer Funktionsinstanz mit der Invokation mit den Argumenten vorzubelegen, macht diese Abstraktion parametrisierbar.
Dieses Konzept gibt den Entwicklern die Möglichkeit selbst neue Abstraktionen innerhalb des Programms zu schaffen.
Man könnte sagen, dass Prozeduren die Sprachabstraktion sind, die es erlaubt benutzerdefinierte Abstraktionen zu erschaffen.
Wie bereits mehrfach erwähnt, wird dann der Funktionsaufruf, die Invokation, zu einem **Komplexbefehl**, der sich wie andere Operationen verhält, dessen Semantik aber von den Entwicklern definiert wurde.
Eine Sprache mit Prozeduren schafft also eine virtuelle Maschine, die innerhalb der Maschine erweitert werden kann.

Es gibt unterschiedliche Nomenklaturen für Prozeduren, die sich teilweise leicht in ihrer Bedeutung unterscheiden. Insbesondere im nächsten Kapitel, wenn es um funktionale Programmierung geht, werden wir einen Unterschied zwischen Prozeduren, die Seiteneffekte haben dürfen, und Funktionen, die frei von Seiteneffekten sind, unterscheiden. Meist hat diese Unterscheidung in den Namen aber keine besonders große Relevanz, und sie wird daher meist recht beliebig verwendet.

Mit den Prozeduren bekommt eine Sprache auch die Chance für ihr erstes Entwurfsprinzip, die **prozedurale Abstraktion**.
Sogleich ich vorne angekündigt habe, nicht weiter auf Prinzipien einzugehen, werde ich es hier doch tun, weil man durch dieses Prinzip sehr gut den Unterschied zwischen Paradigma und Prinzip erklären kann.
Bei der prozeduralen Abstraktion geht es darum eine, in sich logisch abgeschlossene, Aufgabe in einer Prozedur zu platzieren und mit einem möglichst sprechendem Namen zu versehen.
Dies ist ein Entwurfsprinzip, eine Anweisung, wie man das Sprachkonzept der Prozeduren verwenden sollte um nicht wahnsinnig zu werden.
Das Konzept "Prozedur" hält einen nicht davon die Prozedurgrenzen so zu ziehen, dass eine zusammengehörige Aufgabe zerschnitten und auf mehrere unabhängige Prozeduren verteil wird, die scheinbar zufällig hintereinander aufgerufen werden. Zur Verschleierung des eigentlichen Zwecks der Prozedur ist das ein valides Vorgehen, wenn wir allerdings das Verständnis maximieren wollen, sollten wir uns darauf versteifen das Prinzip der prozeduralen Abstraktion anzuwenden.

#+begin_src latex
  \begin{frame}{Benannter und veränderlicher Zustand}
    \begin{columns}
      \begin{column}{0.25\textwidth}
        \btAnimation[width=\textwidth]{range=1-3:<1->,3:<4->}{fig/11-state}
      \end{column}\hfill
      \begin{column}{0.65\textwidth}
        \bi
        \ii<2-> Eingaben und (Zwischen-)ergebnisse speichern{%
          \bi
          \ii Speicherzellen mit symbolischem Namen
          \ii Objekte werden an diese Namen gebunden
          \ii Späterer Zugriff über das Symbol
          \ei
        }\medskip
        \ii<3-> \structure{Veränderlicher Zustand} ist ein eigenes Konzept{%
          \bi
          \ii += \structure{Variablen} und \structure{Zuweisung}
          \ii Gebundene Namen können neu gebunden  werden.
          \ii Flexibler Datenfluss und Schleifen mit Auswirkung
          \ei
        }\medskip
        \ii<handout:4-|4-> Variablen sind Quelle unendlich vieler \ALERT{Bugs} {
          \bi
          \ii Variablen sind ein Seitenkanal zu den Parametern
          \ii Funktionsverhalten kann überraschend werden
          \ii Zustand kann inkonsistent werden.
          \ei
        }
        \ei

      \end{column}
    \end{columns}
  \end{frame}
#+end_src  

Nun könnte man meinen, wir wären schon fertig mit den Konzepten, die das imperative Paradigma ausmachen, aber es fehlt noch ein ganz entscheidendes  Konzept, dass wir als so selbstverständlich hinnehmen, dass wir es kaum als ein eigenes Konzept wahrnehmen. Erst die Beschäftigung mit anderen Sprachen, die aktiv auf dieses Konzept verzichten, merken wir, dass es ein eigenständiges Konzept ist: **der benannte und veränderliche Zustand**.

In der Diskussion um Werte- und Referenzmodell{{{see(06-value-reference-model,Werte- und Referenzmodell)}}}, haben wir gesehen, dass Variablen und Objekte echt unterschiedliche Konzepte sind.
Neben der relativ naheliegenden Idee einer Variable einen Namen zu geben, ist der Schritt den Wert einer Variable zu ändern ein deutlich folgenreicherer.
Durch die Zuweisungsoperation können wir den Inhalt einer Variable ändern und so den Variablennamen an ein neues Objekt binden.
Variablen sind auch das Konzept was es uns erlaubt einen flexiblen Datenfluss über komplexe Kontrollfstrukturen hinweg zu notieren. Ohne Variablen müsste jede Instruktion die Ergebnisse ihrer Vorgängeroperation empfangen, ein Ergebnis ändern und an die nächste Operation weitergeben. Durch Variablen bekommen wir die Möglichkeit Werte zwischen zu speichern und zu einem späteren Zeitpunkt wieder zu verwenden. 

Können wir eine veränderliche Variablen global definieren, haben wir die Möglichkeit eines Datenflussseitenkanal über Prozedurgrenzen hinweg  geschaffen. Durch ein globales Konfigurationsflag kann sich unsere Prozedur, aufgerufen mit den selben Argumenten wie vor 3 Milisekunden, plötzlich ganz anders verhalten. Dies bietet eine große Flexibilität, aber auch eine Quelle von Bugs. Diesem Problem werden wir dann in der Vorlesung über das funktionale Paradigma nachgehen.

#+begin_src latex
  \begin{frame}{Das imperatives Programmierparadigma}
    \begin{center}
      \includegraphics[width=0.6\textwidth]{fig/11-procedural-paradigma.pdf}
    \end{center}

    \bi
    \ii Das \structure{imperative Programmierparadigma} umfasst mehrere Konzepte{
      \bi
      \ii Operationen: Sequenzierung, Konstrolstrukturen, Prozeduren
      \ii Daten: Strukturierte Daten, benannter und veränderlicher Zustand
      \ii Beispiele für rein imperative Sprachen: Fortran, COBOL, PL/I, C, Pascal
      \ei
    }\medskip
    \ii Imperatives Programmieren ist oft das Paradigma \structure{\enquote{im Kleinen}}{
      \bi
      \ii Starke Kontrolle des Programmierers über die Ausführung (\ALERT{--}, \advantage{+})
      \ii Java, Rust, C++ bieten alle das imperative Paradigma an.
      \ei
    }
    \ei
  
  \end{frame}
#+end_src

Zusammengefasst ist das imperative Paradigma, die Kombination aus veränderlichem strukturiertem Zustand und einer starken Kontrolle für die Entwickler über den Kontrollfluss.
Das imperative Paradigma, was das Paradigma, was man als solches bezeichnen kann, und prägt bis heute die Welt der Programmiersprachen grundlegend. Oft verwenden Sprachen, die auf einer höheren Organisationsebene ein anderes Paradigma bieten, in ganz Kleinen, auf der Ebene einzelner Befehle, das imperative Paradigma. So ist Java auf der großen Organisationsebene objekt-orientiert, verwendet jedoch innerhalb von Methoden das imperative Paradigma um den Entwicklern die Kontrolle über die Ausführung zu geben.

* Das objekt-orientierte Programmierparadigma
:PROPERTIES:
:CUSTOM_ID: 11-oo-paradigm
:END:

#+begin_src latex
  \dividerframe{Das objektorientierte\\Programmierparadigma}

  \begin{frame}{Probleme imperativen Programmierens}
    \btAnimation[width=0.6\textwidth]{1:<1->,center,padding=1ex}{fig/11-the-object}
    \bi
    \ii Imperativ: \textbf{Betonung} der Operationen bei \ALERT{Vernachlässigung} der Daten{%
      \bi
      \ii \alert{Codeduplikation}, da Funktionen sind strikt an ihre Datentypen gekoppelt.
      \ii \alert{Keine Kontrolle}, da programmweiter Zugriff auf Datenstrukturen möglich
      \ii \alert{Leicht unübersichtlich}, da kaum bis keine Hierarchie der Funktionen.
      \ei
      $\Rightarrow$ Erfordert Disziplin und geistige Kapazität von den Entwicklern.
    }\medskip
    \ii<2-> Besonders problematisch bei \textbf{großen Softwareprojekten} {
      \bi
      \ii Wartung von dupliziertem Code macht N-fachen Aufwand.
      \ii Viele Entwickler arbeiten an der gleichen Quellcodebasis.
      \ii Prozedurale Abstraktion bietet nur eine Ebene von Abstraktion.
      \ei
    }
    \ei
  \end{frame}

  \begin{frame}{\enquote{Objekte} als zentraler Begriff}
    \OrangeBox{Menschen denken eher in Objekten (Nomen) als in Aktionen (verben)}
    \begin{columns}
      \begin{column}{0.33\textwidth}
        \begin{btBlock}{Prozedural}
          Fahrrad waschen\\
          Apfel waschen
        \end{btBlock}
      \end{column}\hfill
      \begin{column}{0.33\textwidth}
        \begin{btBlock}{Objekt-Orientiert}
        Fahrrad \btSetTab waschen\\
        \btUseTab fahren
      \end{btBlock}
      \end{column}
    \end{columns}
    \medskip
    \bi
    \ii<2-> Entwurf entlang von Objekten spiegelt menschliche Erfahrungswelten {
      \bi
      \ii Eine Fabrik besteht aus: Hallen, Arbeitern, Maschienen, einem Gelände.
      \ii All diese Entitäten haben (veränderliche) \structure{Eigenschaften}.
      \ii Entitäten \structure{interagieren miteinander} anstatt verarbeitet zu werden:\\
      Arbeiter motiert Reifen $\Rightarrow$ montieren(reifen, by=arbeiter)
      \ei
    }
     \ei

     \begin{btBlock}<3->[type=alert]{}
     Diese (objekt-orientierten) Objekte sind eine Erweiterung unserer bisherigen Objekte aus Vorlesung "06 - Objekte".
   \end{btBlock}
  \end{frame}
#+end_src

Nachdem wir uns mit dem altbekanntem imperativen Paradigma beschäftigt haben, wollen wir uns nun den objektorientierten Paradigma zuwenden.
Wir tun dies, indem wir zuerst die Schwächen des imperativen Paradigmas für große Softwareprojekte diskutieren, bevor wir den Ansatz den Objektorientierung für diese Schwächen aufzeigen.
Als virtuellen Ausgangspunkt wählen wir eine imperative Sprache, die auch in ihrem Typssystem eher simpel und monomorph ist. Denken Sie an C oder an Pascal, beides keine konzeptionell reiche Sprachen.

Wie wir gesehen haben hat das imperative Paradigma mehrere Konzepte, die sich mit der Ausführung beschäftigen, aber nur ein Konzept (Records) was uns dabei hilft unsere Daten im Programm zu strukturieren. Diese Vernachlässigung der Datenseite begründet einige der Probleme, die einfache imperative Sprachen zeigen. Zum einen Zwingt uns ein monomorphes Typssystem dazu das Prinzip der prozeduralen Abstraktion zu brechen, da die gleiche Operation auf unterschiedliche Datentypen ausgeführt in zwei unterschiedlichen Prozeduren münden muss. Dies führt zu einer Codeduplikation, die den Wartungsaufwand, der besonders bei großen Softwareprojekten einen erheblichen Teil der Kosten ausmacht, erhöht.
Ebenso bietet das imperative Paradigma keinerlei Zugriffskontrolle über die Daten und jede Prozedur ist erst einmal gleichberechtigt alle Daten, für die sie einen Zeiger erhaschen kann, zu manipulieren. Dies erfordert, gerade bei vielen Entwicklern, die an der gleichen Quellcodebasis arbeiten, ein enormes Maß an Disziplin, welche erlernt und eingehalten werden muss.
Zum letzten bietet das rein imperative Paradigma kein Konzept zur Bündelung mehrerer semantisch zusammenhängender Prozeduren. Sicherlich gibt es die Möglichkeit Prozeduren, die zusammen gehören, ähnlich benennen. Aber auch das Erfordert Disziplin von den Entwicklern. Ab einer Vielzahl von Prozeduren, wird die Menge aller Prozeduren zu einem großen See in dem man keinerlei Struktur mehr erkennen kann.
Was man bräuchte wäre eine zweite Art von Strukturkonzept für Codeorganisation. Teilweise kann dies durch Module bewerkstelligt werden, aber auch Objektorientierung bietet hier Konzepte an.

Wie der Name schon vermuten lässt, stellt die Objektorientierung (OO) nicht mehr die Prozedur in den Mittelpunkt, sondern das Objekt.
Vergleichen wir Objekte und Prozeduren mit der natürlichen Sprache, so kommen wir zur Analogie, dass Objekte wie Nomen und Prozeduren wie verben sind.
Die Konzentration von OO auf Objekte verschiebt somit den Fokus vom "was getan wird" zu einem "wem" getan wird.
Auf den Folien zeige ich ein Beispiel, welches verdeutlicht, dass diese Verschiebung zu intuitiveren Programmstrukturen führen kann.
Bei Konzentration auf verben, würden wir "Apfel waschen" und "Fahrrad waschen" in der gleichen Kategorie verorten, es wird ja schließlich etwas gewaschen.
Nun sind beide Reinigungstätigkeiten zwar ähnlich, haben aber in ihren Werkzeugen und ihrem Ziel nur sehr wenig miteinander zu tun.
Anders sieht es aus, wenn wir und auf die Nomen konzentrieren und unser Fahrrad in den Mittelpunkt stellen.
An diesen zentralen Begriff hängen wir dann die verben an, die zu diesem Objekt passen:
"waschen" und "fahren".
Und schon haben wir, durch die Verschiebung des Fokuspunktes eine Organisation gefunden, die viel mehr den menschlichen Erfahrungen entspricht, die die Welt eher nach ihren Objekten und weniger nach ihren Operationen sortiert.

Die Grundidee von OO ist das Objekt als eigenständige Entität zu denken, dass eine Menge von Eigenschaften hat und über **Methoden** mit anderen Objekten interagiert. Dieses Mitdenken der Methoden als Teil des Objekts ist ein anderer Objektbegriff als der, den wir in Vorlesung "06 - Objekte" gebraucht habe. Denken Sie also für diese Vorlesung beim Begriff Objekt immer ein implizites "OO-" Prefix dazu. 


#+begin_src latex
  \begin{frame}{Nachrichten und Objekte}
    \begin{center}
      \includegraphics[width=0.7\textwidth]{fig/11-messages}    
    \end{center}

    \begin{btBlock}{Definition nach Alan Kay (Erfinder von Smalltalk)}
      \small
      \be
      \ii \structure{Messaging}: Objekte kommunizieren durch den Versand von Nachrichten.
      \ii \structure{Persistenz}: Objekte haben privaten Zustand, auch wenn sie nicht aktiv sind.
      \ii \structure{Kapselung}: Informationen werden im Objekt verborgen.
      \ii \structure{Späte Bindung}: Ausgeführte Operation wird spätmöglichst ausgewählt.
      \ee
    \end{btBlock}
  \end{frame}

  \begin{frame}{Konzepte für Objektorientierung}
    \btAnimation[height=7cm]{range=3-5:<1->,center,padding=1ex}{fig/11-the-object}
  \end{frame}


  \begin{frame}<handout:4>[fragile]{Die Methode als die zentrale Erweiterung}
    \bi
    \ii Methoden haben einen \structure{Ausführungskontext} mit dem Objekt{
      \bi
      \ii Objekt auf der die Methode aufgerufen wird, wird sichtbar.
      \ii Objektattribute sind in der Methode zugreifbar.
      \ii Methode ist eine Closure! (Siehe \enquote{03 - Namen})
      \ei
    }\medskip
    \ii \structure{Closure}: Eine Prozedur die einen Ausführungskontext mitbringt\\ {
      \bgroup\btAnimation[width=0.8\textwidth]{1:<1-2>,2:<3>,3:<4>,center,padding}{fig/11-closure}\egroup
      \bi
      \ii Prozeduren werden \textbf{immer} in einem Kontext ausgeführt.
      \ii Bei C sind nur die Argumente und die globalen Variablen enthalten
      \ii Bei Closures sind zusätzliche Objekte an Namen gebunden (z.B. \structure{\texttt{this}})
      \ei
    }
    \ei
  \end{frame}
#+end_src

Wie wir bereits gesagt haben stehen beim objektorientierten Paradigma stehen die (OO-)Objekte im Mittelpunkt. Um dies noch etwas genauer zu fassen wollen wir uns die Definition von Objektorientierung von Alan Kay, dem Erfinder von Smalltalk, der ersten objektorientierten Programmiersprache, anschauen.

Für Kay ist das wichtigste Element von OO das **Messaging** zwischen Objekten. Anstatt Prozeduren mit Argumenten aufzurufen findet alle Interaktion über Nachrichten statt. Objekte schicken anderen Objekten Nachrichten, welche auf diese Nachrichten reagieren. Technisch umgesetzt werden diese Nachrichten mittels Methodenaufrufe, aber das mentale Bild soll sein, dass einzelne Objekte anderen Objekten eine Nachricht schicken. Denken Sie dabei nicht an Netzwerknachrichten, sondern an etwas abstrakteres. Das Firmenobjekt schickt dem Arbeiter eine Nachricht mit der nächsten Aufgabe.
In Java ist dies durch, dem Objekt angehängte, Methoden implementiert.

Der zweite Aspekt von OO ist die **Persistenz** des privaten Objektzustandes. Objekte representieren eigenständige Entitäten und haben einen internen Zustand, selbst wenn sie gerade keine Nachricht verarbeiten. Technisch gesehen bedeutet dies, dass die Eigenschaften des Objekts im Speicher residieren müssen um über Methodenaufrufe hinweg Zustand zu halten. Dabei hat jedes Objekt seinen **eigenen** privaten Zustand.
In Java ist dies durch Objekteigenschaften implementiert{{{see(03-composite-types,Zusammengesetzte Typen)}}}.

Für Kay ist der dritte Prüfstein von OO, dass die Eigenschaftes des Objekts im Objekt selbst gekapselt sind und nicht von außen zugegriffen werden können.
Dabei stellen die Methoden des Objekts das "Innen" dar, und jeglicher andere Code das "Außen".
Hier zeigt sich die klare Erweiterung von OO-Objekten gegenüber Records, die ja von überall zugreifbare Felder beinhalten.
Durch diese Kapselung wird im Code ganz klar, welcher Code einzelne Eigenschaften eines Objekts lesen und verändern darf.
In Java ist dies durch die Feldmodifier ~private~, ~protected~ und ~public~ implementiert{{{see(04-limited-visibility,Einschränkung der Sichtbarkeit)}}}.

Der letzte Aspekt von OO ist für Alan Kay, die Späte Bindung von Nachrichten an Operationen.
Dies bedeutet, dass nicht bei Versenden einer Nachricht entschieden wird, welcher Code tatsächlich ausgeführt wird, sondern erst beim Empfang der Nachricht durch ein Objekt.
Auf diese Weise kann bei OO jedes Objekt unterschiedlich auf gewissen Nachrichten reagieren.
In Java ist dies durch Methoden mit virtuellen Dispatch anhand des dynamischen Typs implementiert {{{see(04-dynamic-dispatch,Überladung und Polymorphismus)}}}.

Gegenüber dem imperativen Paradigma ist die **Methode** das entscheidende ***neue Sprachkonzept**.
Anstatt Prozeduren und Objekte getrennt voneinander zu halten, sind Methoden Prozeduren, die zu einem bestimmten Objekt gehören.
Auf wird der Empfang einer Nachricht durch ein Objekt zu einem Methodenaufruf auf dem entsprechenden Objekt.
Innerhalb der Methode ist das angebundene Objekt sichtbar ohne vom Aufrufendem als Argument mitgegeben zu werden.
Sie kennen dieses Verhalten zum Beispiel bereits aus Java, wo innerhalb einer Methode die Felder des Objekts und das Objekt selbst (als ~this~) sichtbar sind.
In Python ist dieses Sichtbarmachen des Objekts noch deutlicher, da Methoden einen ~self~ Parameter haben, der allerdings nicht als Argument angegeben werden muss.

Um das Kernkonzept der Methode drapieren sich noch die anderen Konzepte mit denen die von Kay geforderten Eigenschaften in OO-Sprachen implementiert werden. Durch Zugriffsmodifier können wir die Sichtbarkeit von Feldern einschränken und so Kapselung erreichen. Durch dynamischen Dispatch/virtuellen Methodenaufruf wird das späte Binden implementiert.

Was auf den Folien noch dazu kommt, was aber in gewisser Weise nicht, wie wir sehen werden, in den vier essentiellen Punkten von Kay nicht enthalten ist, ist das Konzept von Subtyp-Polymorphie durch Vererbung{{{see(03-polymorphism,Polymorphismus)}}}. Denn Kay spricht nur davon, wie sich Objekte zu Verhalten haben, er macht aber keine Aussage darüber wie diese Objekte ins Leben treten und wie wir Prozeduren als Methoden an ein Objekt binden. Bei Vererbung geschieht dies durch eine hierarchische Beziehung von Record-Typen, die in einer Subtyp-Beziehung zueinander stehen und in eine Richtung durcheinander Ersetzbar sind. Im nächsten Unterkapitel werden wir jedoch die Prototypen-basierte Objektorientierung kennen lernen, die gänzlich ohne separate Klassen auskommt und alles über einen Objektbau abhandelt. Seien Sie also gespannt.

Aber zurück zu den Methoden.
Technisch gesehen sind Methoden Closures{{{see(04-call-frames,Function-Call Frames)}}}, also eine Kombination einer Prozedur mit einem (teilweise) gebundenem Ausführungskontext.
Um dies zu Verstehen bedarf es noch einer Diskussion des Ausführungskontextes:
Innerhalb einer Prozedur werden Referenzen zu Variablen über den Ausführungskontext aufgelößt.
In einer C-Funktion beinhaltet dieser Ausführungskontext die gebundenen Parameter und die lokalen Variablen der aktuellen Funktionsinstanz.
Zusätzlich sind aber auch alle globalen Variablen im Ausführungskontext einer C-Funktion und zwar über Funktionsinkarantionen hinweg.
In C haben wir also nur zwei Ebenen von hierarchisch Ausführungskontext: dem lokalen der Funktionsinstanz (für jeden Aufruf ein neuer Kontext) und den globalen Kontext (immerwährend).

Für OO müssen wir uns einen dritten, dazwischenliegenden Kontext vorstellen, in dem das aktuelle Objekt (und teilweise dessen Felder) gebunden sind. Bei der Namensauflösung{{{see(04-implicit-resolution,CNSR)}}} werden diese Kontexte (zur Laufzeit!) von innen nach außen durchsucht bis der Variabelenname zum gebundenen Objekt aufgelößt werden kann.
Durch diesen erweiterten Ausführungskontext ist eine Methode etwas wirklich anderes als eine Prozedur. Denn im Gegensatz zur Prozedur hat die Methode eines Objekts einen Zustand, nämlich die persistent-gespeicherten Eigenschaften des Objekts.
Technisch löst der Übersetzer diesen erweiterten Ausführungskontext effizient durch einen impliziten ~this~-Parameter durch. Aber das haben wir nun wirklich schon oft genug in diesem Skript erklärt. Kommen wir also wieder mal zu etwas ganz neuem: Prototypen.

** Prototyp-basierte Objektorientierung
:PROPERTIES:
:CUSTOM_ID: 11-prototype-oo
:END:
#+begin_src latex
\dividerframe{Prototypen}
  \begin{frame}{Objekt-Orientierung ohne Klassen}
    \begin{btBlock}{}
      Da Sie alle OO auf Basis von Klassen zur Genüge kennen, werden wir eine andere Art der OO Programmierung betrachten.
    \end{btBlock}
    \medskip
    \bi
    \ii Javascript kennt \ALERT{keine Klassen} und ist \ADVANTAGE{dennoch} Objekt-Orientiert{
      \bi \def\C{\bgroup\textcolor{safegreen}\checkmark\egroup}
      \ii Javascript-Objekt haben Attribute (\C) gebundene Methoden (\C)
      \ii Methoden werden erst beim Aufruf aufgelößt (\C)
      \ii Informationen können mittels lexikalischem Scoping verborgen (\C) werden
      \ei
    }\medskip
    \ii JavaScript verwendet \structure{Prototypen-basierte Vererbung}{
      \bi
      \ii Flexibler, Erweiterbarer, und Mächtiger als klassenbasierte Vererbung
      \ii Hohe Dynamik, die besonders für eine Skriptsprache geeignet ist
      \ii Wenige Sprachmechanismen, aber ein gewisser Zoo an syntaktischem Zucker
      \ei
    }
    \ei
  \end{frame}

  \begin{frame}<handout:1,3>[fragile]{JavaScript: Die Prototypenkette}
    \begin{columns}
      \hfill
      \begin{column}{0.49\textwidth}
        \begin{code}[]
          \begin{JS}
            var obj = { a: 23 };
            obj.zz = 42;
            [obj.a, obj["a"], obj["zz"]];
            // => [23, 23, 42]
          \end{JS}
        \end{code}
      \end{column}\hfill
    \end{columns}

    \bi
    \ii JavaScript-Objekte sind \emph{\enquote{bags} of properties}{
      \bi
      \ii Zugriff über \texttt{[]} und den Punktoperator
      \ii Recordtyp und Abbildungstyp fallen zusammen
      \ii Properties können zu einem Objekt hinzugefügt werden
      \ei
    }\medskip
    \ii<handout:2-|2-> \texttt{\_\_proto\_\_}: Fallback für die Suche nach Attributen{
      \bi
      \ii Situation: Ein Objekt hat das geforderte Attribut nicht
      \ii Die Suche wird beim Prototypen, der in \texttt{\_\_proto\_\_} referenziert ist, fortgesetzt.
      \ii Es entsteht die \structure{Prototypenkette}, die bei \texttt{\{\}} endet.
      \ei\smallskip
      \btAnimation[width=0.9\textwidth]{1:<1-2>,2:<3>,center,padding}{fig/11-prototypes}
    }
    \ei
  \end{frame}
#+end_src

Da Sie Klassenbasierte Objektorientierung aus Java ja bereits kennen, will ich Sie nicht weiter damit langweilen ihnen Vererbung mittels Klassen noch einmal zu reinterieren. Anstatt dessen wollen wir uns **Prototypen-basierte Objektorientierung** als eine andere Geschmacksrichtung von OO anschauen, die, wie ich finde, sogar die geforderten 4 Eigenschaften noch deutlicher macht, als dies bei Klassenbasierter OO der Fall ist. Als Beispiel werden wir uns  Prototypen-OO in JavaScript, da diese Sprache auf wirklich jedem modernen Gerät im Browser zur Verfügung steht.

Vorneweg, JavaScript unterstützt im Kern keine Klassenbasierte OO, sondern nur Prototypen-OO, obwohl es inzwischen Syntaxzucker gibt, der es so erscheinen lässt als hätte JavaScript Klassen. Diese in [[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes][ECMAScript 2015]] eingeführte Syntax ist am Ende nur ein ganz dünnes Furnier über der eigentlichen Prototypen-basierte JavaScript OO Engine. Wir schauen uns daher nur diese unterliegende Schicht an, in der JavaScript die 4 geforderten Eigenschaften von Ray erfüllt.

Generell kann man sagen, dass Prototypen-OO flexibler ist als Klassenbasierte-OO, da man zur Laufzeit die Methoden und Eigenschaften von bereits erzeugten Objekten verändern kann.
Dies ist nur daher möglich, da JavaScript im Herzen eine im Interpreter dynamisch ausgeführte Skriptsprache ist, auch wenn es heutzutage Just-in-Time Übersetzer gibt, die JavaScript im Browser zu schnell-ausführendem Maschinencode übersetzt.
Um Prototypen-OO in Javascript zu verstehen, muss man zwei Sprachmechanismen verstehen: Die *Prototypenkette* und den JavaScript **Methodenaufruf**.

Schauen wir uns zunächst JavaScript Objekte und die Prototypenkette an.
Die erste wichtige Eigenschaft von JavaScript ist, dass Record- und Abbildungstypen zusammefallen.
In JavaScript ist alles drei einfach ein ~object~.
Diese JS-Objekte können als Sack voller Attribute beschrieben werden, die über einen dynamisch generierten Key abgerufen werden können.
Daher hat JavaScript zwei semantisch äquivalente Notationen um auf Attribute zuzugreifen:
~obj.a~ und ~obj["a"]~ bedeuten exakt das gleiche und greifen auf das Attribut ~a~ des Objekts zu.
Wir können, wie wir auf den Folien sehen, sogar Attribute zu einem bereits existierenden Objekt hinzufügen (~obj.zz~).
Ein leeres Objekt, ohne Attribute, kann in JavaScript einfach über ~{}~ erzeugt werden und dann mit neuen Attributen ausgestattet werden.

#+begin_src javascript
var obj = { a: 23 };
obj.zz = 42;
[obj.a, obj["a"], obj["zz"]];
#+end_src


Die **Prototypenkette** setzt an diesen Objekten an, indem /jedes/ Objekt eine interne Eigenschaft ~__proto__~ hat, die auf ein anderes Objekt verweisen kann (oder ~null~ ist um die Kette abzubrechen).
Das so referenziertes Objekt wird dann als Fallback für die Suche nach Attributen: Wenn wir, mit dem Punktoperator (~objekt.attribut~) nach einem Attribut suchen, wird zuerst in den **eigenen Attributen** des Objekts gesucht. Hat das Objekt das gesuchte Attribut nicht selbst, so wird die Suche bei dem Objekt, was mittels ~__proto__~ als Prototyp angegeben ist, fortgesetzt. Dort wird die Suche dann noch weiter nach oben Eskaliert, bis das Attribut gefunden wurde oder die Prototypenkette abbricht (~null~).

#+begin_src javascript
var x = {a: 23};
x.__proto__.b = 42;
[x, x.__proto__, [x.a, x.b]]
#+end_src

Durch diesen Mechanismus der Prototypenkette können dynamisch komplexe Vererbungsbeziehungen zwischen Objekten entstehen (es sind keine Klassen involviert):
Objekte, die als Prototypen referenziert sind, vererben ihre Attribute dynamisch an alle Kinder, ohne deren Datenlayout zu verändern.
Fügt man zu so einem Objekt, dass weit oben in der Prototypenkette steht, ein Attribut zu, "erben" alle Objekte, die direkt oder indirekt auf dieses Objekt verweisen, das Attribut.
Die einzige Ausnahme ist, dass ein Objekt das Attribut selbst als eigenes Attribut hat, da in diesem Fall die Attributsuche abgebrochen wird, bevor wir zum Prototypenobjekt kommen.

Da in JavaScript alle Objekte gleichberechtigt sind, gibt es keine Unterscheidung zwischen Klassen und Objekten. Jedes Objekt kann als Prototyp für eine ganze Reihe von anderen Objekten stehen. Insgesamt bilden so alle JS-Objekte einen großen Prototypen-Baum, mit dem leeren Object (~{}~) als Wurzel. Man kann sogar durch ~({}).__proto__.x = 42~ jedem existierenden Objekt das Attribut ~x~ unterschieben (Die Klammern braucht man, damit der Parser nicht hustet).

  #+begin_src latex
  
  
  \begin{frame}[fragile]{JavaScript: Attribut-Lookup und \texttt{this}}
    \bi
    \ii Prototypenkette implementiert dynamischen und hierarchischen Lookup{%
      \bi
      \ii Objekt in der Kettenmitte erweitern $\rightarrow$ Alle Kinder werden erweitert
      \ii Speichereffizient, aber mit höhreren Lookup-Kosten verbunden.
      \ei
    }\medskip
    \ii<2-> JavaScript bindet den Namen \structure{\texttt{this}} an das aktuelle Objekt{
      \bi
      \ii Attribute können auf Funktionen verweisen.
      \ii Objekt-Attribut als Funktion aufrufen $\Rightarrow$ \texttt{this} wird das Objekt gebunden
      \ei
    }
    \ei
    \begin{columns}<2->
      \begin{column}{0.49\textwidth}
        \begin{code}[tag=JavaScript]
          \begin{JS}[]
            var obj = {
              prop: 37,
              f: function() {
                return this.prop;
              }
            };
            var ff = obj.f;
          \end{JS}
        \end{code}
      \end{column}\hfill
      \begin{column}{0.49\textwidth}
        \bii
        \ii Aufruf der Funktion als Attribut\\
            \codeinline{obj.f()} $\Rightarrow$ \codeinline{37}\\[2ex]
        \ii Aufruf der \enquote{blanken} Funktion\\
            \codeinline{ff()} $\Rightarrow$ \codeinline{undefined}
        \eii
      \end{column}
    \end{columns}
  \end{frame}

  \begin{frame}[t,fragile]{JavaScript: Funktionen als Konstruktoren}
    \bi
    \ii \textbf{Alle} Funktionen können als Konstruktoren verwendet werden{
      \bi
      \ii Das Schlüsselwort \structure{\texttt{new}} ruft Funktion im Kontext eines neuen Objekts auf.
      \ii Jede Funktion hat eine \structure{\texttt{.prototype}}-Attribut, die als \texttt{\_\_proto\_\_} gesetzt wird.
      \ei
    }
    \ei

    \begin{columns}[t]
      \begin{column}{0.49\textwidth}
        \begin{code}[]
          \begin{JS}
            function Foo(name) {
              this.name = name;
            }
          \end{JS}
          \begin{onlyenv}<handout:2-|2->
          \vspace{1em}
          \begin{JS}
            var obj = new Foo("alice");
          \end{JS}
        \end{onlyenv}%
        \begin{onlyenv}<handout:3-|3->\vspace{1em}
            \begin{JS}
            Foo.prototype.getLength = \
              function() {
                return this.name.length;
              };

            obj.getLength() // => 5
          \end{JS}
        \end{onlyenv}
      \end{code}%
      \begin{onlyenv}<2|handout:2>
        \begin{center}
          dies ist äquivalent zu
        \end{center}
        \begin{code}
          \begin{JS}<3-|handout:3->
            var obj = {
              __proto__: Foo.prototype
            }
            // Aufruf mit this == obj
            obj.constructor("alice");
          \end{JS}
        \end{code}
      \end{onlyenv}

      \end{column}\hfill
      \begin{column}{0.49\textwidth}\centering
        \btAnimation[width=2.7cm]{raisebox,range=1-3:<1->,3:<4>}{fig/11-js-constructors}
      \end{column}
    \end{columns}
    \bi
    \ii<4-|handout:4-> Modernes JavaScript bietet \structure{\texttt{class}} und \structure{\texttt{extends}} als syntaktischen Zucker
    \ei
  \end{frame}

  \begin{frame}{Prototypen-basierte Objektorientierung}
    \bi
    \ii Objekte erben alle Eigenschaft ihrer Prototypen {
      \bi
      \ii JavaScript: Dynamischer Lookup entlang der Prototypenkette
      \ii Konstruktion der Prototypen-Hierarchie mittels \structure{\texttt{new}}
      \ii Sieht aus wie klonen, ist aber effizienter.
      \ei
    }\medskip
    \ii Alle Objekte sind \structure{gleichberechtig} und können Prototypen werden {
      \bi
      \ii Keine Unterscheidung zwischen Objekten und Klassen.
      \ii JavaScript: \texttt{obj.\_\_proto\_\_} zeigt wieder auf ein Objekt
      \ii Es entsteht ein Baum von Objekten die Prototypen füreinander sind.
      \ii Die Wurzel des Baums ist das leere Objekt: \texttt{\{\}}
      \ei
    }\medskip
    \ii Veränderung eines Prototypen ändert alle erbenden Objekte {
      \bi
      \ii JavaScript: Eingebaute Objekte können erweitert werden (discouraged)
      \ii \codebox{Array.prototype.forEach = function(...) \{ ... \}}
      \ii Alle Objekte können jetzt \texttt{forEach}: \codebox{[2,3,4].forEach(...)}
      \ei
    }
    \ei
  \end{frame}
#+end_src

Durch die Prototypenketten können wir relativ Speichereffizient eine Vielzahl an Objekten dynamisch Attribute hinzufügen. Allerdings kostet und diese Speichereffizienz und die Dynamik und Flexibilität der Attribut-Lookups Laufzeit. Im Zweifel muss ja jeder Attributzugriff durch das Abgehen der gesamten Prototypenkette aufgelößt werden. Für eine Scriptsprache ein valider Trade-Off zwischen Flexibilität und Laufzeit; für eine übersetzte Sprache würden wir uns zweimal überlegen ein solches Feature einzubauen.

Der zweite Mechanismus, mit dem JavaScript dann endgültig zur OO Sprache wird, ist die Art und Weise wie der **Methodenaufruf** geschieht. Vorneweg muss man erklären, dass in JavaScript Funktionen an jeder Stelle erzeugt werden können (~var FUN = function () { return 23;};~) und auch wieder aufgerufen werden können (~FUN()~). Daher können Funktionen auch in  Objekt-Attributen gespeichert werden. Die Magie geschieht in JavaScript an der Stelle an der eine Funktion als Attribut eines Objekts aufgerufen wird (~obj.f()~). In diesem Fall wird die Funktion mit einem Ausführungskontext aufgerufen in dem die Variable ~this~ an das Objekt gebunden ist. Extrahiert die Funktion zuerst und ruft sie anderweitig auf (~var ff = obj.f; ff()~), greift dieser Mechanismus nicht!

Durch diese Art des Methodenaufrufs, kann jede Funktion zu einer gebundenen Methode werden, indem man sie als Attribut des Objekts speichert. Zusammen mit der Prototypenkette, kommt man dann schnell dazu, dass es möglich ist solche Methoden zu vererben, indem man eine Funktion als Attribut eines Prototypen-Objekts setzt. Bei der Attributsuche wird dann die Prototypenkette nach oben abgegangen, die Funktion extrahiert und mit gebundenem ~this~ (auf das orginale Objekt) aufgerufen. Fertig ist der virtuelle Methodenaufruf, dessen Bindung zum Zeitpunkt des Aufrufes stattfindet (siehe Späte Bindung).

Da das manuelle aufbauen einer Prototypenkette eher mühsam ist, bietet JavaScript noch einige Mechanismen, die es uns erleichtern, diese Art der Objektorientierung zu verwenden. Eine davon ist die Verwendung von **Funktionen als Konstruktoren**: Für jedes Funktionsobjekt (~Foo~), dass wir anlegen, wird zusätzlich ein Prototypenobjekt (~Foo.protoype~) angelegt, welches ein Attribut ~constructor~ hat, welches (zyklisch) auf die Funktion zeigt. 

Die Instantiierung und Initialisierung von neuen Objekten geschieht über den ~new~-Operator, den man einem normalen Funktionsaufruf vorwegstellt: Zuerst erzeugt der Operator ein leeres Objekt und setzt das ~__proto__~-Attribut auf ~Foo.prototype~, womit es alle Attribute, inklusive ~.constructor~ erbt. Danach wird ~obj.constructor~, also die tatsächliche Funktion, aufgerufen. Da diese als ein Attribut aufgerufen wurde, startet sie mit einer passend gebundenen ~this~ Variable, über die sie das neue Objekt initialisieren kann.

Erweitert man den Prototypen (~Foo.prototype~), kann man alle Objekte, die über ~new Foo(...)~ erzeugt wurden um neue Attribute und Methoden erweitern. Dies funktioniert sogar mit eingebauten Objekten wie ~Array~ oder ~String~, wird aber von der JavaScript Community nicht empfohlen (siehe Prinzipien).

Wenn wir alles Zusammenfassen, Prototypenkette, Methodenaufruf und Funktionen als Konstruktoren, so sehen wir, dass JavaScript eine vollständige objektorientierte Programmiersprache ist, die allerdings ganz ohne Klassen auskommt.
Vielmehr sind alle Objekte gleichberechtigt, und einzig ihre dynamisch änderbare Position in der Prototypenkette bestimmt ihre Rangordnung in der Vererbungshierarchie.
Dies ist sehr flexibel, kann aber auch leicht dazu führen, dass man sich gewaltig in den Fuß schießt.
Daher hat JavaScript inzwischen syntaktischen Zucker (~class~, ~extends~) um klassenbasierte (Einfach-)Vererbung sauber abzubilden.
Was allerdings mit Prototypen-OO nicht abbildbar ist, ist Mehrfachvererbung, da jedes Objekt nur einen Vorgänger in der Prototypenkette hat.


** Kritikpunkte am Objekt-Orientierten Paradigma
:PROPERTIES:
:CUSTOM_ID: 11-oo-critique
:END:

#+begin_src latex
  \dividerframe{Kritik am Objektorientierten Entwurf}

  \begin{frame}<handout:1,3>[fragile]{Konzentration auf Objekte}
    \bi
    \ii Objekt-orientierte Entwurfsmethoden fokussieren Objekte {%
      \bi
      \ii \structure{Verb/Nomen-Analyse} von Use-Case Beschreibungen\\[1ex]
          Alle Nomen werden Klassen/Objekte.\hspace{1em} Alle Verben werden Methoden.\\[2ex]
     \ii Arbeiter (Nomen) montiert (verb) Reifen (Nomen) an Auto (Nomen).\\[2ex]
          \begin{center}
          \begin{tikzpicture}
            \node[rectangle split, rectangle split parts=2,draw] {%
              Arbeiter
              \nodepart{two}%
              void montieren(Reifen, Auto)
            };
          \end{tikzpicture}
        \end{center}
        \ei
      }\bigskip
      \ii<2-> \ALERT{Kritik}: Objekt-Orientierung vernachlässigt Verben {\\[1ex]
        \begin{displayquote}[Steve Yegge, Execution in the Kingdom of Nouns][\hfill]
          Object Oriented Programming puts the Nouns \alert{first and foremost}. Why would you go to such lengths to put one part of speech on \textbf{a pedestal}? Why should one kind of concept take precedence over another? It's not as if OOP has suddenly made verbs \alert{less important} in the way we actually think.
        \end{displayquote}
      }
      \ei
    
    \overlayboxHBOX
    \begin{overlaybox}<handout:3-|3->[draw=srared,ultra thick]
      \includegraphics[height=5cm]{fig/11-hund}
    \end{overlaybox}
  \end{frame}

  \begin{frame}[fragile]{Konzeptionell: Verben kommen nie allein!}
    \bi
    \ii Nicht jede Funktionalität kann einem Objekt zugeordnet werden. {
      \bi
      \ii Zu welchem Objekt gehört der Algorithmus \textbf{größter gemeinsamer Teiler}?
      \ii Methode von \texttt{AlgorithmManager}-Klasse?  Unterschiedliche Instanzen?
      \ii Gehört sie zur Klasse \texttt{int}? Hat \texttt{BigInt} eine eigene \texttt{gcd()} Methode?
      \ii[$\Rightarrow$] \textbf{\enquote{Lösung}}: Nicht-instantiierte Klassen die nur statische Methoden beinhalten\\[1ex]
      \begin{center}
        \codebox{void java.lang.Math.sin(double a);}
      \end{center}
      \ei
    }\bigskip
    \ii<2-> Wir können keine blanken Funktion herumreichen {
      \bi
      \ii Callback-Funktionen müssen immer von einem Objekt \enquote{bewacht} werden
      \ii[$\Rightarrow$] Leere Objekte die nur eine Methode \enquote{\texttt{execute()/run()/do()}} haben{
        \begin{center}
          \codebox{void java.lang.Runnable.run();}
        \end{center}
      }\medskip
      \ii \structure{Designpatterns} um diese Schwäche zu umschiffen: Command, Strategy, Proxy
      \ei
    }
    \ei
  \end{frame}

  \begin{frame}{Konzeptionell: Daten kommen nie alleine!}
    \bi
    \ii Von manchen Klassen kann es nur eine Instanz geben {
      \bi
      \ii Manche Entitäten sollten in einem Programm nur einmal existieren.
      \ii Beispiel: Managerobjekt, dass \textbf{alleinige} Kontrolle über einen Aspekt hat.
      \ii \structure{Designpattern}: Singleton (nur möglich durch statische Attribute)
      \ei
    }\bigskip
    \ii<2-> Strikte Objektorientierung kennt keinen \structure{globalen Kontext} {
      \bi
      \ii An welchem Objekt würde eine globale Variable hängen? 
      \ii Globale Variablen erlauben globale Konfiguration des Programmverhaltens\\[1ex]
      \ii[$\Rightarrow$] Durchschleifen von Kontext-Objekten mit Programmoptionen\\[2ex]{
        \hspace{1cm}%
        \btSetTab\codebox{void app.grep.Searcher.search(ProgramContext);}\\
        \btUseTab\codebox{void app.grep.Searcher.iterateDirectory(ProgramContext, Directory);}\\
        \btUseTab\codebox{void app.grep.Searcher.processFile(ProgramContext, String);}\\
          \btUseTab\codebox{void app.grep.Searcher.searchLine(ProgramContext, String);}\\
      }\medskip
      \ii \structure{Designpatterns}, die dieses Problem beheben: Registry, ServiceLocator\\
      \hfill\scriptsize(Beides Singletons)
      \ei
    }
    \ei
  \end{frame}

  \begin{frame}{\enquote{Objektorientierung ist ineffizient!}}
    \bi
    \ii OO-Entwurfsprinzipien verleitet Probleme zu feinschichtig zu zerlegen{\\[1ex]
      \begin{center}
        \includegraphics[page=1,height=1.8cm]{fig/11-call-hierarchy}\hspace{2cm}
        \includegraphics[page=2,height=1.8cm]{fig/11-call-hierarchy}
      \end{center}

      \bi
      \ii Verteilung der Verantwortlichkeit auf viele Objekte
      \ii Unübersichtlicher Kontrollfluss zwischen den einzelnen Methoden
      \ii Viele Methodenaufrufe zwischen den Schichten.
      \ei
    }\medskip
    \ii<2-> Hohe Kosten für den einzelnen  Methodenaufrufe{
      \bi
      \ii \structure{Späte Bindung}: Dynamic Dispatch wählt Methode zur Laufzeit auf
      \ii \structure{this}: Der implizite durchgeschleifte Parameter ist nicht umsonst.
      \ei
      \medskip
      \begin{displayquote}[Joe Armstrong, Erlang Erfinder][\\\hfill]\small
        The problem with object-oriented languages is they've got all this implicit environment that they carry around with them. You wanted a banana but what you got was a gorilla holding the banana and the entire jungle.
      \end{displayquote}
    }
    \ei
  
    \overlayboxHBOX
    \begin{overlaybox}<handout:3-|3->[draw=srared,ultra thick]
      \includegraphics[height=8cm]{fig/11-callstack}
    \end{overlaybox}
  \end{frame}
#+end_src

Bevor wir mit der Diskussion des Objektorientierten Paradigmas zum Ende kommen, und auf Vorbereitung der nächsten Vorlesung, will ich noch einige Kritikpunkte aufgreifen, die an diesem Paradigma geäußert worden sind.
Diese Kritik ist dabei selten am Paradigma selbst, sondern mehr auf die Prinzipien seiner Verwendung, gerichtet.
Dennoch fußen ja all diese Prinzipien auf den Mechanismen, die wir im OO Paradigma vereinigt haben und daher lohnt es sich an dieser Stelle einen Blick auf die Kritik zu werfen.

Um diese Kritik zu verstehen, muss man sich kurz die Grundüberlegung von OO vor Augen halten: Alle Entitäten sind Objekte, die Nachrichten austauschen. OO legt also einen großen Fokus auf die Objekte, was sich auch in der OO Entwurfsmethode der **Verb/Nomen-Analyse** niederschlägt. Diese wird verwendet um Software objektorientiert zu entwerfen. Dazu geht nimmt man sich definierte Use-Cases zu Hand, markiert sich alle Nomen und alle verben, die sich auf diese Nomen beziehen. Ganz grob vereinfacht, sagt man dann, dass alle Nomen Objekte/Klassen werden und die verben, untergeordnet, als Methoden an diese Objekte gehangen werden. Ich werde das hier nicht tiefer ausführen, da es eigentlich ein Thema des Software Engineering ist. Was wir allerdings in dieser Entwurfsmethodik sehen, ist dass die verben den Nomen untergeordnet werden.

Der erste, relativ philosophische, Kritikpunkt zielt dann auch genau darauf ab, dass Verben vernachlässigt: Durch die OO Designphilosophie haben wir uns Jahrelang nur auf die Objekte versteift und Software danach gebaut, wie wir die alles einzelnen Objekten zuordnen können. Aber deswegen sind verben, also Tätigkeiten bzw. Aktionen, ja nicht weniger wichtig geworden. Allerdings zwingt uns das Objektorientierte Paradigma dazu, jedenfalls wenn man es konsequent durchzieht, dass Tätigkeiten (verben) niemals alleine auftreten können. Sondern sie werden gewissermaßen immer von einem Objekt an der Leine geführt. Aus dieser gezwungenen Kopplung ergeben sich dann auch die anderen Kritikpunkte, die man am OO Paradigma anbringen kann.

So stellt sich bei manchen Aktionen (wir nennen sie dann mal wieder Funktionen), die Frage zu welchem Objekt sie gehören sollen.
An welchem Objekt sollte denn die Funktion "größter gemeinsamer Teiler" hängen?
Sollte es eine Methode von "Integer" sein?
Was ist dann mit anderen Objekten, die sich auch wie eine Ganzzahl verhalten, aber in keiner Vererbungsbeziehung zu Integer stehen (z.B.
BigInt).
Sollte die ihre eigene Implementierung für ~gcd()~ mitbringen?
Und was sollte jemand tun, der sich einen neuen Algorithmus überlegt, der Ganzzahlen verarbeitet?
In Java kann man ja von außen nicht einfach eine Methode an eine bereits definierte Klasse ranflanschen.
Das ist alles schwierig.
Daher wählt für dieses Problem häufig die Lösung über Klassen die nur **statische Methoden** beinhalten.
Diese Klassen dienen nur als Container für statische Methoden, sollen aber nie instantiiert werden.
Das Paradebeispiel dafür ist Javas ~java.lang.Math~ Klasse, die alle wichtigen mathematischen Funktionen beinhaltet.
An diese Stelle werden die Prinzipien des Objektorientierten Designs absichtlich umgangen, indem die Konzepte des Objektorientierten Paradigmas missbraucht werden.
Dieses Muster, dass Konzepte, die anders verwendet werden solle, missbraucht wird um Probleme mit den Designprinzipien zu umgehen werden wir noch häufiger sehen.
Oft genug nennen wir diese kreativen Lösungen dann **Designpattern** und schreiben Bücher darüber.

Ziemlich Ähnlich zum letzten Problem ist das Herumreichen von blanken Funktionen.
Da eine Methode immer an einem Objekt hängt, können wir nicht einfach einen Funktionszeiger herumreichen. So ist es bei Java nicht möglich eine Methode als Argument zu übergeben (~foo(obj.method)~).
Der Workaround für dieses Problem ist dann oft, dass man eine Klasse ohne Attribute erzeugt, die genau eine Methode beinhaltet. Um jetzt diese Methode herum zu reichen, erzeugt man ein Objekt für die Klasse und reicht das herum. Auf diese Weise kann man den selben Effekt erreichen, als hätte man Funktionszeiger, da das Objekt ja die gebundene Methode Huckepack herum reicht. Allerdings, und da liegt das wirkliche Problem: Der Aufrufende muss den Methodennamen statisch kennen. In Java ist es (jedenfalls bevor es Lambdas gab) nicht möglich anonyme Funktionsobjekte herum zu reichen.
Um dieses Problem zu Umschiffen gibt es sogar mehrere Designpatterns (Command, Strategy, Proxy), die als Surrogat für Funktionszeiger verwendet werden.


Das dritte Problem von (Klassenbasierter)  Objektorientierung ist die Illusion, dass es von jedem Objekttyp beliebig viele Instanzen geben kann. Allerdings gibt es manche Instanzen auf der Welt, von der es genau eins gibt, und von der auch nicht aus Versehen ein Zweites erzeugt werden sollte. Beispiele dafür sind Managerobjekte, von globale Daten verwalten. Ein solches Beispiel ist die Verwaltung der globalen Konfiguration des Programms. Es wäre wirklich schlecht, wenn es zwei konkurrierende globale Konfigurationsobjekte innerhalb eines Programms geben würde. Um dieses Problem zu umgehen, wurde das **Singleton**-Designpattern erfunden, dass sicherstellt, dass eine Klasse nur genau einmal instantiiert wird. Wieder ein Entwurfsmuster, dass die Prinzipien von Objektorientierung gegen den Strich bürstet, weil die wahren Anforderungen doch nicht ganz in das Muster passen. Wieder ist beim Singleton, der Umweg über statische Attribute und Methoden erforderlich (Scheinbar ein ganz guter Indikator dafür, wenn etwas nicht ganz  ins OO Schema passt).

Direkt angedockt an das Problem der singulären Instantiierung ist das Problem des **globalen Kontextes**. In reiner Objektorientierung kann es keine globale Variable geben, denn an welchem Objekt sollte dieses Variable denn als Attribut hängen. Das heißt, dass wir keinerlei Möglichkeit haben globale Variablen als Seitenkanal für Konfigurationsflags zu verwenden. Eine Möglichkeit dies zu "beheben" ist, dass man ein generisches ~ProgramContext~ Objekt überall als Parameter durch schleift. Dies ist allerdings wirklich kein schönes Muster und zudem nicht komponierbar. Was würden wir machen wenn unser Hauptprogram einen ~ProgramContext~ durch eine Bibliothek, die keine Ahnung von dieser Klasse hat, durch schleifen wollen würde? Geht nicht. Der einzige Ausweg sind wieder, Sie ahnen es, Designpatterns. In diesem Fall Registry und ServiceLocator, beides selbst wiederum Singletons.

Der dritte Kritikpunkt an Objektorientierung ist seine Ineffizienz.
Wo die Prozedurale Abstraktion kein Problem damit hat innerhalb einer Prozedur eine Vielzahl von Objekten zu verarbeiten (rechte Seite auf der Folie), wäre man bei Objektorientiertem Design dazu angehalten, die Funktionalität auf viele Methoden aufzuteilen. Dies geschieht dabei im Vorauseilendem gehorsam, denn irgendwann könnte irgendjemand mal auf die Idee kommen für eine der Klassen die Methode in einer Unterklasse zu überschreiben. Den Preis für diese Flexibilität zahlen wir allerdings die ganze Zeit bis dahin: Zum einen wird der Code, durch die Aufteilung auf viele Methoden, schwerer überschaubar, und zu anderen Zahlen wir Laufzeitkosten für die beständigen virtuellen Methodenaufrufe. Auch das implizite durch schleifen des ~this~-Zeigers ist, obwohl es auf Ebene des Quellcodes unsichtbar ist, nicht umsonst. Und man zahlt die Kosten bei jedem Methodenaufruf.

In der nächsten Vorlesung schauen wir uns dann das funktionale Paradigma an, bei dem wir wirklich nur die Banane bekommen, und nicht immer gleich den ganzen Dschungel mitnehmen müssen.

* Zusammenfassung

#+begin_src latex
  \begin{frame}{Zusammenfassung}
    \bi
    \ii Programmierparadigmen sind Sammlungen von Sprachkonzepten {
      \bi
      \ii Ausweiten der Semantischen Lücke macht eine Sprache \alert{nicht mächtiger},\\
          aber den Code leichter \advantage{verständlicher}.
      \ii Paradigmen werden durch Software-Enginnering Prinzipien diszipliniert.
      \ei
    }
    \ii Das imperative Programmierparadigma {
      \bi
      \ii Sequentielles Abarbeiten von Operationen, die den Zustand verändern.
      \ii Strikte Vorgabe, wie eine Aufgabe durch zu führen ist.
      \ii Prozedurale Abstraktion zerlegt das Problem entlang von Aufgaben
      \ei
    }
    \ii Das objekt-orientierte Programmierparadigma {
      \bi
      \ii \structure{Interagierende Objekte} sollen die reale Welt abbilden
      \ii Objekte senden \structure{Nachrichten} bzw. rufen sich ihre Methoden gegenseitig auf
      \ii Prototypen erlauben \structure{klassenlose Objektorientierung}
      \ei
    }
    \ii Objekt-Orientierung hat ebenfalls \alert{Probleme} {
      \bi
      \ii Funktionen werden immer von Objekten dominiert.
      \ii Globaler Kontext nur über statische Methoden/Attribute
      \ii Designpatterns müssen konzeptionelle Schwächen ausgleichen
      \ei
    }
    \ei
  
  \end{frame}
#+end_src

