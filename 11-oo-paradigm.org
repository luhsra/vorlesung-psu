#+TITLE: 11 - Das Objektorientierte Programmierparadigma
#+SETUPFILE: setup.org
#+DATE: [2020-07-07]
#+INCLUDE: export-prologue.org
#+VIDEO_URL: https://flowcasts.uni-hannover.de/nodes/wYklY
#+PROPERTY: header-args:latex :tangle yes :noweb yes :tangle-macros yes :tangle-prologue topic :tangle-epilogue endtopic :exports none

#+NAME: topic
#+BEGIN_SRC latex :tangle no
\psuSectionStart{{{{property(ITEM)}}}}{{{{n(block)}}}}
#+END_SRC

#+NAME: endtopic
#+BEGIN_SRC latex :tangle no
\psuSectionStop{{{{property(ITEM)}}}}{{{{n(block,-)}}}}
#+END_SRC

* Gedanken zu dieser Vorlesung                                     :noexport:
- Was ist das Grundlegende Problem?
  - Softare ist Komplex => Kein Problem für die Maschiene
  - Software Complexity ist ein Problem für Menschen
  - Zum einen muss es in den Kopf eines einzigen Menschen passen.
  - Zum anderen braucht man eine gemeinsame Sprache mit seinen Mitentwicklern.

- Was ist ein Programmierparadigma?
  - https://www.info.ucl.ac.be/~pvr/VanRoyChapter.pdf
  - Paradigma: Eine Menge von zusammenhängenden Konzepten die miteinander harmonieren.This chapter is partly based on the book [50], familiarly known as CTM, which givesThis chapter is partly based on the book [50], familiarly known as CTM, which gives
  - Konzepte sind zu Paradigmen gruppiert.
  - Sprachen implementieren 1..N Paradigmen. Meistens mehrere
  - Die Paradigmen helfen dabei das Programm zu strukturieren.

- Das Imperative Paradigma
  - State + Procedure + Record
  - State: Benannter Zustand
  - Procedure:  Sequenzierung von mehreren Befehlen zu einem Ablauf
  - Record:     Strukturierte Objekte

  => Wie Dekonstruiert man damit ein großes Problem?

- Das Objekt-Orientierte Paradigma
  - Closures: Prozeduren mit teilweise aus dem Environment gebundenen Variablen
  - => Instantiierbare Namensräume mit Methoden sind Closures.

  - Was machen Leute damit?
    Sie Bilden die Strukturen der Realen Welt auf Objekte ab => User

    Design: Class Structure vs. Object Structure

    => Wie dekonstruiert man damit ein großes Problem?

  - Kritik an OO: Es gibt keine Algorithmen ohne Zustand

    The problem with object-oriented languages is they've got all this implicit environment that they carry around with them.
    You wanted a banana but what you got was a gorilla holding the banana and the entire jungle.



* Paradigmen und Komplexität
:PROPERTIES:
:CUSTOM_ID: 11-einleitung
:END:
#+begin_src latex
  \subtitle{{{{subtitle()}}}}
  \maketitleframe

  \begin{frame}{Wiederholung: Die semantische Lücke}
  \begin{columns}
    \begin{column}{0.30\textwidth}
      \begin{center}\small
        \includegraphics[width=1.5cm]{fig/01-problem}\\\relax
        [Problem]\\[1ex]
        \fbox{\parbox{0.8\textwidth}{\centering
            Hochsprache\\
            $\Uparrow$\\
            \structure{Semantische Lücke}\\
            $\Downarrow$\\
            CPU-Steuersignale
          }}\\[1ex]\relax
        [Ausführung]\\\relax
        \includegraphics[width=1.5cm]{fig/01-cpu}
      \end{center}
    \end{column}\hfill
    \begin{column}{0.65\textwidth}
      Mit unserem Übersetzer haben wir die semantische Lücke \advantage{überwunden}:

      \begin{center}
        Source $\rightarrow$ AST $\rightarrow$ IR $\rightarrow$ ASM $\rightarrow$ ELF
      \end{center}

      \bii
      \ii Beschreibung des Problems in Hochsprache
      \ii Schrittweises Absenken der Abstraktion
      \ii Schichten versprechen wohldefinierte Semantiken.
      \eii

      \bigskip
      \pause
      \ALERT{Aber:} \btSetTab Warum türmen wir überhaupt \\\btUseTab diese semantische Lücke auf?

      \bii
      \iida Lernkurve: Abstraktionen müssen gelernt werden
      \iida Fehleranfällig: Übersetzer können Bugs haben
      \iida Abstraktionen erzeugen oft einen Overhead
      \eii

      \OrangeBox{Welchen Nutzen hat die semantische Lücke?}
    \end{column}
  \end{columns}
  \end{frame}

  \begin{frame}{Komplexität und Nichtdeterminismus}
    \bi
    \ii Große Systeme haben zwei Dimensionen, die das \structure{Verständnis} erschweren{%
      \bi
      \ii \structure{Komplexität}: Anzahl der interagierenden Elemente?
      \ii \structure{Nichtdeterminismus}: Wie vorhersagbar sind die Interaktionen?
      \ei
    }\bigskip
    \ii<2-> \textbf{Beispiel}: Das gesamte Universum {
      \bi
      \ii Viele Elemente (Atome), die  zufällig interagieren (Quantenmechanik)
      \ii Für das Funktionieren des Universums ist das egal
      \ii Für unser Verständnis vom Universum ein Problem
      \ei
    }\bigskip
    \ii<3-> Ein großes Programm als ein großes System {%
      \bi
      \ii Viele Elemente (Daten) interagieren miteinander (abhängige Operationen).
      \ii Für die Maschine egal. Operationen werden stumpf nacheinander ausgeführt.
      \ii \structure{Problem Menschen}: Da sie es nicht verstehen, können sie es nicht bauen.
      \ei
    }
    \ei
  \end{frame}

  \begin{frame}{Mensch vs. Maschine}
    \centering
    \btAnimation[height=8cm]{range=1-4:<1->}{fig/11-complexity}
  \end{frame}

  \begin{frame}{Konzepte, Paradigmen, Prinzipien}
    Damit wir Menschen \textbf{komplexe Systeme} bauen, verstehen und kommunizieren können, brauchen wir Abstraktionen und Strukturen.

    \bigskip

    \bi
    \ii Sprachen bieten Abstraktionen zum Denken und Kommunizieren{%
      \bi
      \ii \structure{Konzepte}: Welche Abstraktionen kann es überhaupt geben?\\[1ex]
         Beispiele: Records, Zustand, Prozeduren, Closures, Threads, Nachrichten\\[3ex]
      \ii \structure{Paradigmen}: Welche Abstraktionen nutze ich in Kombination?\\[1ex]
      Beispiel: Imperativ  = Records + Zustand + Sequenzierung + Prozeduren\\[3ex]
      \ii \structure{Prinzipien}: Wie nutze ich die Abstraktionen (ohne Knieschuss)?\\[1ex]
      Beispiel: Liskovsches Substitutionsprinzip\\
      \onslide<2>{$\Rightarrow$    Software Engineering}
      \ei
    }
    \ei
  \end{frame}


  \begin{frame}<handout:4>{Hierarchie der Begrifflichkeiten}
    \centering
    \btAnimation[width=0.7\textwidth]{range=1-4:<1->}{fig/11-principles}
  \medskip
    \bii
    \ii<2->  Paradigmen bündeln Konzepte zu einem konsistenten Programmiermodell.
    \ii<3-> Es gibt \ALERT<3->{viel mehr} Sprachen als Paradigmen.
    \ii<4-> Die meisten Sprachen bedienen mehr als ein Paradigma.\\[1ex]
    Oft: Ein Paradigma für \structure{Grobstruktur} + Ein Paradigma für die \structure{Feinstruktur}
    \eii
  \end{frame}
#+end_src

In den letzten zehn Vorlesungseinheiten haben wir uns mit dem Thema Programmiersprachen und ihrer Übersetzung von zwei Seiten genähert.
Zum einen haben wir in vier Vorlesungen (Typen, Namen, Objekte, Operationen) einzelne Sprachkonzepte auf einem sehr kleinteiligen Niveau kennen gelernt.
Zum anderen haben wir uns mit den einzelnen Schritten der Übersetzung (Syntaxanalyse, Semantische Analyse, Zwischencodeerzeugung, Optimierung und Maschinencodeerzeugung) auseinandergesetzt.
In dieser und der nächsten Vorlesung wollen wir wieder einen Schritt zurück machen und uns die grundsätzliche Fragen "Warum haben wir überhaupt Programmiersprachen?" und "Folgen einzelne Sprachen ähnlichen Paradigmen?" stellen.

Mit den verwendeten Sprachkonzepten erlauben Programmiersprachen es uns, ein Problem auf einer abstrakten Ebene und mit einem großen Abstand zu einer real existierenden Maschine zu formulieren.
Dieser Abstand ist die semantische Lücke und der Übersetzer (oder auch ein Interpreter) überbrückt diese Lücke auf automatisierte Art- und Weise.
Dabei stellt sich aber die Frage, warum wir diese semantische Lücke aufbauen, wenn wir dafür zusätzliche Werkzeuge brauchen, um sie wieder zu überbrücken.
Neben der Tatsache, dass Übersetzer leicht anfällig für Bugs sind, erzeugen komplexe Sprachkonstrukte eine Lernkurve, die von den Entwicklern erst überwunden werden muss, bevor diese effektiv und effizient arbeiten können.
Welchen Nutzen hat es demnach, die semantische Lücke aktiv auszuweiten und sogar eventuelle Overheads, die bei der Abbildung auf die Maschine entstehen, in Kauf zu nehmen?

Für die Maschine tun wir dies sicherlich nicht, da diese in allen Fällen das Programm gleich ausführt, egal wie groß die semantische Lücke zum Quellprogramm vorher war.
Für die Maschine brauchen die Daten auch keine Struktur, da auf der untersten Ebene einer Von-Neumann-Maschine der Datenspeicher ein großes ~char~-Array ist und das Programm ein Array von Instruktionen.
Vielmehr müssen wir den Nutzen der semantischen Lücke bei den Entwicklern, insbesondere denen großer Softwaresysteme, suchen.

In großen Softwareprojekten erzeugt das Zusammenspiel von drei Aspekten eine besondere Qualität babylonischer Verwirrung bei den Entwicklern:
Eine große Menge von heterogenen Informationen (Objekte) wird von vielen Operationen verarbeitet, wobei einzelne Operationen in ihren Ausführungen voneinander abhängig sein können{{{see(07-operation-dependencies,Abhängigkeiten zwischen Operationen)}}} und daher in einer gewissen Reihenfolge abgearbeitet werden.
Dieses komplexe Netz interagierender Elemente wird dabei nicht nur von einem einzelnen Entwickler orchestriert, sondern von einem oder mehreren Entwicklungsteams, die über die gesamte Erde, in unterschiedlichen Zeitzonen und mit unterschiedlichem kulturellen Hintergrund, verteilt an dem Programm arbeiten.
Und hier kommt das eigentliche Problem bei der Programmierung: **Wie können wir den Menschen das Verständnis und die Kommunikation von Programmcode erleichtern?**

Diese Aufgabe stellt sich als gar nicht so einfach heraus.
Wollen wir zunächst einmal die beiden Prozessoren vergleichen:
Auf der einen Seite des Rings stehen die mechanischen Rechenanlagen (Computer), die eine große Menge an Speicher haben, auf den sie mit großer Bandbreite uniform (jeder Zugriff dauert in etwa gleich lange) zugreifen können.
Zusätzlich zu diesem perfekten Gedächtnis führen Maschinen in jedem Operationszyklus eine strikt definierte Aktion durch; ohne Gnade, ohne Zögern, ohne Fehler und ohne Müdigkeit, immer uniform.
Auf der anderen Seite befinden sich unsere Gehirne, die im direkten Vergleich nicht gut abschneiden:
Der Speicher eines Menschen ist begrenzt und nicht erweiterbar, Zugriffe dauern unterschiedlich lange (erinnern) und können verfälschte, oft nur assoziierte, Ergebnisse liefern.
Die Verarbeitung der abgerufenen Ergebnisse ist langsam, fehleranfällig, und nicht zu selten uneindeutig.
Noch schlimmer wird es, wenn zwei Menschen miteinander kommunizieren: Wo wir zwei identisch arbeitende Maschinen mit dem gleichen Programm ausstatten können, haben zwei Menschen niemals das gleiche Set an Assoziationen, was unweigerlich zu Missverständnissen führt. Außerdem hat der Kommunikationskanal nur eine sehr geringe Datenrate, was im krassen Gegensatz elektrischen oder opto-elektrischen Computernetzen steht.
Das eigentliche Problem ist also nicht die Maschine, sondern der Mensch, der diese in Gemeinschaft mit anderen versucht zu instruieren.

Um mit der Komplexität von Systemen umzugehen, haben wir ein unfassbar nützliches Werkzeug entwickelt:
**die Abstraktion**.
Durch die Abstraktion strukturieren wir große Probleme und Lösungen in immer kleiner werdende Partikulärprobleme und -lösungen.
Dabei muss ein Mensch nicht die gesamte Lösung für ein Problem verstehen, sondern kann auf einer Abstraktionsstufe stoppen und die Lösung aus Partikulärlösungen der nächst niedrigeren Stufe komponieren.
Um das etwas anschaulicher zu gestalten:
Die Abstraktion Record bietet uns die Möglichkeit, viele Objekte mit gleicher Struktur zu erstellen und auf die einzelnen Felder zuzugreifen.
Dabei müssen wir uns (meist) keine Gedanken machen, wie diese Felder in den Speicher gelegt werden oder wie die Offsets berechnet werden.
Durch die Verwendung der Abstraktion können wir das Datenlayout und die Adressberechnungen dem Übersetzer überlassen und den Programmcode für einen Algorithmus auf einem deutlich abstrakteren Niveau formulieren.
Am Ende arbeitet das Programm ebenso, als hätten wir die Adressberechnungen direkt mit dem Algorithmus vermischt, aber durch die Verwendung der Abstraktion wird das Programm deutlich verständlicher und für andere einfacher zu verstehen.

Im Rahmen von Programmiersprachen können wir die angebotenen Abstraktionen mit Begrifflichkeiten fassen:
Auf der kleinteiligsten Ebene finden wir die **Konzepte** einer Sprache.
Jedes Konzept ist eine Abstraktion, die von der Sprache bereitgestellt wird.
So ist die Möglichkeit, einen Record Datentypen anstatt manuelle Adressberechnungen zu verwenden, ebenso ein Sprachkonzept, wie die Möglichkeit Prozeduren zu erstellen ein Konzept ist.
Aber auch höhere Abstraktionen, wie Threads (Ausführungsfäden) oder Nachrichten, können Sprachkonzepte darstellen, wenn diese direkt in der Spezifikation der Sprache angeboten werden.

Aus einer Kombination von Konzepten kann man ein **Paradigma** formen.
Ein Paradigma ist eine aufeinander abgestimmte Menge von Konzepten, die man in einer Sprache verwenden kann.
Ein Paradigma stellt quasi einen vorgefertigten Werkzeugkasten an Konzepten dar, aus dem man sich bedienen kann, um ein konkretes Problem zu lösen.
Als Beispiel kann hier das imperative Paradigma dienen, welches es erlaubt, Daten strukturiert als veränderlichen Zustand abzulegen und durch sequentiell abgearbeitete Prozeduren zu verarbeiten.
Andere Paradigmen können die Menge der angebotenen Konzepte vergrößern (das objektorientierte Paradigma), aber auch bewusst einschränken (das funktionale Paradigma).

Haben wir einmal ein Paradigma (=Werkzeugkasten) definiert und wird es von einer Sprache angeboten, stellt sich noch die Frage, wie wir die enthaltenen Konzepte (=Werkzeuge) kombinieren können, ohne uns beständig in den Fuß zu schießen.
Solche "best practices" nennen wir **Prinzipien** und sie sind Thema des Software Engineerings. Dort lernen Sie, wie Sie Objektorientierung richtig verwenden und sich, zum Beispiel, bei Vererbung an das [[https://de.wikipedia.org/wiki/Liskovsches_Substitutionsprinzip][Liskovsche Substitutionsprinzip]] halten.
In dieser Vorlesung wollen wir uns nicht weiter mit Prinzipien auseinandersetzen, sonder bei den Konzepten und, in dieser und der nächsten Vorlesung, bei den Paradigmen bleiben.

Grundlegend festzustellen ist, dass es deutlich mehr Programmiersprachen als Paradigmen gibt.
So gibt es viele Sprachen, die das objektorientierte Paradigma, teils in unterschiedlichen Geschmacksrichtungen, aber häufig mit großer Ähnlichkeit, implementieren.
Allerdings ist zu beobachten, dass moderne Sprachen sich nicht nur auf die Implementierung eines Paradigmas beschränken, wie das bei frühen Sprachen der Fall war, sondern oft mehrere Paradigmen beinhalten. Damit werden diese zu einer **Multi-Paradigmensprache** und bieten gewissermaßen mehrere Werkzeugkoffer an, aus denen sich die Entwickler bei der Lösung der gestellten Probleme bedienen können. Eine Übersicht und eine detaillierte Diskussion von Programmierparadigmen finden Sie im Kapitel [[https://www.info.ucl.ac.be/~pvr/VanRoyChapter.pdf]["Programming Paradigms for Dummies: What Every Programmer Should Know"]] von Peter Van Roy. Insbesondere die Taxonomie auf Seite 13 (Figure 2) gibt einen großen Überblick über das Thema Programmierparadigmen und wie diese miteinander im Zusammenhang stehen.

* Das imperative Programmierparadigma
:PROPERTIES:
:CUSTOM_ID: 11-imperative-paradigma
:END:


In diesem Unterkapitel widmen wir uns dem imperativen Paradigma, dem grundlegendsten Paradigma, das wir für die Entwicklung von Programmen verwenden können.
Dabei zähle ich das Sprachkonzept der "Prozeduren" zum imperativen Paradigma hinzu und mache keine gesonderte Unterscheidung zwischen rein imperativem Programmieren (ohne Prozeduren) und einem prozeduralen Paradigma (mit Prozeduren), da diese Unterscheidung seit dem Aufkommen strukturierter Programmierung in den 60ern nicht mehr von tatsächlicher Relevanz ist.
Aber seien Sie gewarnt, Sie können da draußen auf Menschen treffen, die diese Unterscheidung machen und pedantisch auf ihr beharren.

#+begin_src latex
  \dividerframe{Das Imperative Paradigma}

  \begin{frame}{In the Beginning,\ldots}
    \btAnimation[width=\textwidth]{range=1-2:<1->}{fig/11-organization}

    \medskip
    \bi
    \ii   \ldots all data was unstructured and all operations were floating.{
      \bi
      \ii<2->[+=] \structure{Records}: Daten werden zu Datenstrukturen zusammengefasst.
      \ii<2->[+=]\structure{Sequenzierung}: Befehle nacheinander ausführen, Ergebnisse weitergegeben
      \ei
    }\medskip
    \ii<2-> Beispiel: Reverse Polish Notation (wie in PostFix) {
      \bi
      \ii Von links nach rechts ausführen, impliziter Stack für die Berechnung
      \ii \texttt{1 3 + 5 4 - *} == \texttt{(1 + 3) * (5 - 4)}
      \ei
    }
    \ei
  \end{frame}
#+end_src

Um das imperative Paradigma zu charakterisieren, werden wir die einzelnen Sprachkonzepte beleuchten, die es ausmachen.
Diese Konzepte haben Sie alle, in dieser oder in anderen Veranstaltungen, bereits kennengelernt, jedoch vielleicht bisher nicht als voneinander abtrennbar wahrgenommen.
Daher wollen wir die einzelnen Konzepte nun durchgehen und Sie können sich bei jedem Konzept fragen, ob es wirklich notwendig für eine Sprache ist, und wie die Sprache aussähe, wenn es dieses Konzept nicht gäbe.
Auf diese Weise bekommen Sie ein besseres Gefühl für den Designspace, in dem sich die Sprachentwickler bewegen, wenn sie ein neues Paradigma entwickeln.

Zunächst schauen wir uns den Urzustand einer (virtuellen) Maschine an, die nur aus Daten und Operationen besteht.
Stellen Sie sich vor, beides würde frei im Raum herum schweben und muss erst noch strukturiert durch Konzepte abstrahiert werden.
Das erste Konzept, was allen Paradigmen gemein ist, ist die **Strukturiertheit der Daten**.
Anstelle eines großen Sees aus Zahlen (der ganze Speicher als ein ~char~-Array) wollen wir einzelne Objekte haben, die eine innere Struktur haben.
Ausgedrückt wird dieses Konzept zum Beispiel durch Record-Datentypen. Damit können wir einzelne Objekte und deren innere Struktur deklarieren.
Ohne diese Strukturiertheit kann es keine abstrakte Programmiersprache geben, da man keine semantische Verbindung mehrerer Informationshäppchen formulieren kann.

Als Beispiel für Sprachen, die ausschließlich diese Strukturiertheit, und sonst nichts weiter, bieten, kann man Auszeichnungssprachen wie XML bezeichnen.
Dort gibt es nur Objekte und deren hierarchisch geschachtelte Struktur, aber keiner Operationen.
Daher ist XML als Sprache nicht Turing-vollständig und daher nicht zum Programmieren geeignet. Dennoch bietet XML nützliche Abstraktionen, um Probleme zu abstrahieren.

Als zweites Konzept des imperativen Programmierens kann die **Sequentielle Ausführung von Operationen** gelten.
Die Idee, dass die Entwickler angeben, in welcher konkreten Reihenfolge einzelne Operationen mit welchen Daten ausgeführt werden, gibt uns die Möglichkeit, ein Problem in viele Einzelschritte zu zerlegen. Jede Operation ist die Abstraktion ihrer elektronischen Implementierung, und die Aneinanderreihung von Operationen ist die Verwendung dieser Abstraktion.
Durch die Sequenzierung geben die Entwickler eine strikte Reihenfolge vor, wie Operationen ausgeführt werden sollen und wählen so selbst eine Linearisierung der Operationsabhängigkeiten. Fragen Sie sich: Wie sähe ein Sprache aus, bei denen Abhängigkeiten zwischen Operationen ganz frei, wie in einem Abhängigkeitsgraphen, formuliert werden können. Und warum wäre das für die Übersichtlichkeit, einem unserer primären Ziele bei der Sprachentwicklung, nicht nützlich.

#+begin_src latex
  \begin{frame}{Kontrollfluss und Prozeduren}
    \begin{columns}
      \begin{column}{0.35\textwidth}
        \btAnimation[width=\textwidth]{range=1-3:<1->}{fig/11-prozeduren}
      \end{column}\hfill
      \begin{column}{0.58\textwidth}
        \bi
        \ii<2-> Komplexe Abläufe als Kontrollfluss {
          \bi
          \ii[+=] \structure{Selektion}: Endlich können wir eine Operation auch mal auslassen.\\[1ex]
          \ii[+=] \structure{Iteration}: Endlich können wir eine Operation mehrfach ausführen ohne sie doppelt zu notieren.
          \ei
        }\medskip
        \ii<3-> \textbf{Wiederverwendung} durch \structure{Prozeduren} {
          \bi
          \ii Operationen werden ein Verbund und bekommen einen Namen.
          \ii Parameter und Rückgabewerte
          \ii[+=] \structure{Invokation}: Starte die Ausführung des Operationsverbundes.
          \ei
        }
        \ei
        \bigskip
        \onslide<3->{
          \scriptsize (Beinahe) Synonyme: Funktionen, Prozedur, Routinen
        }
      \end{column}
    \end{columns}
  \end{frame}

  \begin{frame}[fragile]{Entwurfsprinzip: Prozedurale Abstraktion}
    \bi
    \ii Prozeduren sind eine \ALERT{technische Einrichtung} der Sprache{
      \bi
      \ii Gibt uns das grundlegende Prinzip der Code-Wiederverwendung
      \ii Die Sprache schreibt \textbf{nicht} vor, wie diese zu Verwenden sind.
      \begin{columns}
        \hfill
        \begin{column}{0.4\textwidth}
          \begin{code}[]
            \begin{py}
              def step3():
                 step1()
                 doIntermediateStep()
                 step2()
            \end{py}
          \end{code}        
        \end{column}\hfill\mbox{}
      \end{columns}
      \ei
    }\bigskip
    \ii<2-> \structure{Prozedurale Abstraktion}: Zerlegung des Problems in Teilprobleme{
      \bi
      \ii Aufteilung des Codes anhand \textbf{problemspezifischer Grenzen}
      \ii Eine Funktionalität $\rightarrow$ Eine Prozedur
      \ii Implementierung der Funktionalität wird hinter dem Funktionsnamen versteckt und kann problemlos ausgetauscht werden (z.B. Bugfix).
      \ei
      \begin{code}[]
        \begin{CPP}
          char *strstr(const char *haystack, const char* needle);
        \end{CPP}
      \end{code}
    }
    \ei
  \end{frame}
#+end_src

In die gleiche Richtung wie die Sequenzierung stoßen die Konzepte der **generellen Kontrollflusskonstrukte**, die es uns ebenfalls Erlauben, den Ausführungsstrom zu beeinflussen.
Dabei haben wir die Konzepte **Selektion** und **Iteration** für den Kontrollfluss im kleinen, und **Prozeduren** und **Invokation** im Großen kennengelernt. 

Durch kleinteilige Konzepte sind wir in der Lage, komplexe Abläufe zu strukturieren und Abhängig von den Eingabedaten unterschiedliche Kontrollflüsse auszuführen. Dabei gibt es diese generellen Konzepte in unterschiedlichen Abstraktionsniveaus: Eine "Schleife" mit ~if~ und ~goto~ hat sicherlich ein geringeres Abstraktionsniveau als eine logisch kontrollierte Schleife, welche wiederum weniger abstrakt ist als eine Aufzählungsschleife über eine dynamisch berechnete Sequenz von Objekten.
Stellen Sie sich vor, welchen enormen technischen Fortschritt es dargestellt hat, eine Maschine zu bauen, die ihre selbst berechneten Ergebnisse verwendet, um ihre zukünftige Operationsweise zu beeinflussen. Einfach der Hammer, im Vergleich zum [[https://en.wikipedia.org/wiki/Centrifugal_governor][Fliehkraftdrehregler]] unendlich flexibler.

Ebenfalls bedeutend sind die **Prozeduren**, welche die parametrisierbare Wiederverwendung von Code erlauben.
Eine Menge von Operationen, die zum Beispiel durch Sequenzierung, Selektion und Iteration strukturiert wurden, können durch eine Prozedur wiederverwendbar gemacht werden.
Durch die Möglichkeit, die lokalen Variablen innerhalb einer Funktionsinstanz mit der Invokation mit den Argumenten vorzubelegen, ist diese Abstraktion parametrisierbar.
Dieses Konzept gibt den Entwicklern die Möglichkeit, selbst neue Abstraktionen innerhalb des Programms zu schaffen.
Man könnte sagen, dass Prozeduren die Sprachabstraktion sind, die es erlaubt, benutzerdefinierte Abstraktionen zu erschaffen.
Wie bereits mehrfach erwähnt, wird dann der Funktionsaufruf, die Invokation, zu einem **Komplexbefehl**, der sich wie andere Operationen verhält, dessen Semantik aber von den Entwicklern definiert wurde.
Eine Sprache mit Prozeduren schafft also eine virtuelle Maschine, die innerhalb der Maschine erweitert werden kann.

Es gibt unterschiedliche Nomenklaturen für Prozeduren, die sich teilweise leicht in ihrer Bedeutung unterscheiden. Insbesondere im nächsten Kapitel, wenn es um funktionale Programmierung geht, werden wir einen Unterschied zwischen Prozeduren, die Seiteneffekte haben dürfen, und Funktionen, die frei von Seiteneffekten sind, unterscheiden. Meist hat diese Unterscheidung in den Namen aber keine besonders große Relevanz, und sie wird daher meist recht beliebig verwendet.

Mit den Prozeduren bekommt eine Sprache auch die Chance für ihr erstes Entwurfsprinzip, die **prozedurale Abstraktion**.
Sogleich ich vorne angekündigt habe, nicht weiter auf Prinzipien einzugehen, werde ich es hier doch tun, weil man durch dieses Prinzip sehr gut den Unterschied zwischen Paradigma und Prinzip erklären kann.
Bei der prozeduralen Abstraktion geht es darum, eine in sich logisch abgeschlossene Aufgabe in einer Prozedur zu platzieren und mit einem möglichst sprechendem Namen zu versehen.
Dies ist ein Entwurfsprinzip, eine Anweisung, wie man das Sprachkonzept der Prozeduren verwenden sollte, um nicht wahnsinnig zu werden.
Das Konzept "Prozedur" hält einen nicht davon ab, die Prozedurgrenzen so zu ziehen, dass eine zusammengehörige Aufgabe zerschnitten und auf mehrere unabhängige Prozeduren verteilt wird, die scheinbar zufällig hintereinander aufgerufen werden. Zur Verschleierung des eigentlichen Zwecks der Prozedur ist das ein valides Vorgehen, wenn wir allerdings das Verständnis maximieren wollen, sollten wir uns darauf versteifen, das Prinzip der prozeduralen Abstraktion anzuwenden.

#+begin_src latex
  \begin{frame}{Benannter und veränderlicher Zustand}
    \begin{columns}
      \begin{column}{0.25\textwidth}
        \btAnimation[width=\textwidth]{range=1-3:<1->,3:<4->}{fig/11-state}
      \end{column}\hfill
      \begin{column}{0.65\textwidth}
        \bi
        \ii<2-> Eingaben und (Zwischen-)Ergebnisse speichern{%
          \bi
          \ii Speicherzellen mit symbolischem Namen
          \ii Objekte werden an diese Namen gebunden
          \ii Späterer Zugriff über das Symbol
          \ei
        }\medskip
        \ii<3-> \structure{Veränderlicher Zustand} ist ein eigenes Konzept{%
          \bi
          \ii += \structure{Variablen} und \structure{Zuweisung}
          \ii Gebundene Namen können neu gebunden  werden
          \ii Flexibler Datenfluss und Schleifen mit Auswirkung
          \ei
        }\medskip
        \ii<handout:4-|4-> Variablen sind Quelle unendlich vieler \ALERT{Bugs} {
          \bi
          \ii Variablen sind ein Seitenkanal zu den Parametern
          \ii Funktionsverhalten kann überraschend werden
          \ii Zustand kann inkonsistent werden
          \ei
        }
        \ei

      \end{column}
    \end{columns}
  \end{frame}
#+end_src  

Nun könnte man meinen, wir wären schon fertig mit den Konzepten, die das imperative Paradigma ausmachen, aber es fehlt noch ein ganz entscheidendes Konzept, das wir als so selbstverständlich hinnehmen, dass wir es kaum als ein eigenes Konzept wahrnehmen. Erst bei der Beschäftigung mit anderen Sprachen, die aktiv auf dieses Konzept verzichten, merken wir, dass es ein eigenständiges Konzept ist: **der benannte und veränderliche Zustand**.

In der Diskussion um Werte- und Referenzmodell{{{see(06-value-reference-model,Werte- und Referenzmodell)}}} haben wir gesehen, dass Variablen und Objekte echt unterschiedliche Konzepte sind.
Neben der relativ naheliegenden Idee einer Variable einen Namen zu geben, ist der Schritt den Wert einer Variable zu ändern ein deutlich folgenreicherer.
Durch die Zuweisungsoperation können wir den Inhalt einer Variable ändern und so den Variablennamen an ein neues Objekt binden.
Variablen sind auch das Konzept, was es uns erlaubt, einen flexiblen Datenfluss über komplexe Kontrollstrukturen hinweg zu notieren. Ohne Variablen müsste jede Instruktion die Ergebnisse ihrer Vorgängeroperation empfangen, ein Ergebnis ändern und an die nächste Operation weitergeben. Durch Variablen bekommen wir die Möglichkeit, Werte zwischenzuspeichern und zu einem späteren Zeitpunkt wieder zu verwenden.

Können wir eine veränderliche Variable global definieren, haben wir die Möglichkeit eines Datenflussseitenkanal über Prozedurgrenzen hinweg geschaffen. Durch ein globales Konfigurationsflag kann sich unsere Prozedur, aufgerufen mit den selben Argumenten wie vor 3 Millisekunden, plötzlich ganz anders verhalten. Dies bietet eine große Flexibilität, aber auch eine Quelle von Bugs. Diesem Problem werden wir dann in der Vorlesung über das funktionale Paradigma nachgehen.

#+begin_src latex
  \begin{frame}{Das imperatives Programmierparadigma}
    \begin{center}
      \includegraphics[width=0.6\textwidth]{fig/11-procedural-paradigma.pdf}
    \end{center}

    \bi
    \ii Das \structure{imperative Programmierparadigma} umfasst mehrere Konzepte{
      \bi
      \ii Operationen: Sequenzierung, Kontrollstrukturen, Prozeduren
      \ii Daten: strukturierte Daten, benannter und veränderlicher Zustand
      \ii Beispiele für rein imperative Sprachen: Fortran, COBOL, PL/I, C, Pascal
      \ei
    }\medskip
    \ii Imperatives Programmieren ist oft das Paradigma \structure{\enquote{im Kleinen}}{
      \bi
      \ii Starke Kontrolle des Programmierers über die Ausführung (\ALERT{--}, \advantage{+})
      \ii Java, Rust, C++ bieten alle das imperative Paradigma an.
      \ei
    }
    \ei
  
  \end{frame}
#+end_src

Zusammengefasst ist das imperative Paradigma die Kombination aus veränderlichem strukturiertem Zustand und einer starken Kontrolle für die Entwickler über den Kontrollfluss.
Es prägt bis heute die Welt der Programmiersprachen grundlegend. Oft verwenden Sprachen, die auf einer höheren Organisationsebene ein anderes Paradigma bieten, im ganz Kleinen, auf der Ebene einzelner Befehle, das imperative Paradigma. So ist Java auf der großen Organisationsebene objektorientiert, verwendet jedoch innerhalb von Methoden das imperative Paradigma, um den Entwicklern die Kontrolle über die Ausführung zu geben.

* Das objektorientierte Programmierparadigma
:PROPERTIES:
:CUSTOM_ID: 11-oo-paradigm
:END:

#+begin_src latex
  \dividerframe{Das objektorientierte\\Programmierparadigma}

  \begin{frame}{Probleme imperativen Programmierens}
    \btAnimation[width=0.6\textwidth]{1:<1->,center,padding=1ex}{fig/11-the-object}
    \bi
    \ii Imperativ: \textbf{Betonung} der Operationen bei \ALERT{Vernachlässigung} der Daten{%
      \bi
      \ii \alert{Codeduplikation}, da Funktionen strikt an ihre Datentypen gekoppelt sind
      \ii \alert{Keine Kontrolle}, da programmweiter Zugriff auf Datenstrukturen möglich
      \ii \alert{Leicht unübersichtlich}, da kaum bis keine Hierarchie der Funktionen
      \ei
      $\Rightarrow$ Erfordert Disziplin und geistige Kapazität von den Entwicklern
    }\medskip
    \ii<2-> Besonders problematisch bei \textbf{großen Softwareprojekten} {
      \bi
      \ii Wartung von dupliziertem Code macht N-fachen Aufwand.
      \ii Viele Entwickler arbeiten an der gleichen Quellcodebasis.
      \ii Prozedurale Abstraktion bietet nur eine Ebene von Abstraktion.
      \ei
    }
    \ei
  \end{frame}

  \begin{frame}{\enquote{Objekte} als zentraler Begriff}
    \OrangeBox{Menschen denken eher in Objekten (Nomen) als in Aktionen (Verben)}
    \begin{columns}
      \begin{column}{0.33\textwidth}
        \begin{btBlock}{Prozedural}
          Fahrrad waschen\\
          Apfel waschen
        \end{btBlock}
      \end{column}\hfill
      \begin{column}{0.33\textwidth}
        \begin{btBlock}{Objektorientiert}
        Fahrrad \btSetTab waschen\\
        \btUseTab fahren
      \end{btBlock}
      \end{column}
    \end{columns}
    \medskip
    \bi
    \ii<2-> Entwurf entlang von Objekten spiegelt menschliche Erfahrungswelten {
      \bi
      \ii Eine Fabrik besteht aus: Hallen, Arbeitern, Maschinen, einem Gelände.
      \ii All diese Entitäten haben (veränderliche) \structure{Eigenschaften}.
      \ii Entitäten \structure{interagieren miteinander} anstatt verarbeitet zu werden:\\
      Arbeiter montiert Reifen $\Rightarrow$ montieren(reifen, by=arbeiter)
      \ei
    }
     \ei

     \begin{btBlock}<3->[type=alert]{}
     Diese (objektorientierten) Objekte sind eine Erweiterung unserer bisherigen Objekte aus Vorlesung "06 - Objekte".
   \end{btBlock}
  \end{frame}
#+end_src

Nachdem wir uns mit dem altbekanntem imperativen Paradigma beschäftigt haben, wollen wir uns nun dem objektorientierten Paradigma zuwenden.
Wir tun dies, indem wir zuerst die Schwächen des imperativen Paradigmas für große Softwareprojekte diskutieren, bevor wir den Ansatz den Objektorientierung für diese Schwächen aufzeigen.
Als virtuellen Ausgangspunkt wählen wir eine imperative Sprache, die auch in ihrem Typsystem eher simpel und monomorph ist. Denken Sie an C oder an Pascal, beides keine konzeptionell reichen Sprachen.

Wie wir gesehen haben, hat das imperative Paradigma mehrere Konzepte, die sich mit der Ausführung beschäftigen, aber nur ein Konzept (Records), was uns dabei hilft, unsere Daten im Programm zu strukturieren. Diese Vernachlässigung der Datenseite begründet einige der Probleme, die einfache imperative Sprachen zeigen. Zum einen zwingt uns ein monomorphes Typsystem dazu, das Prinzip der prozeduralen Abstraktion zu brechen, da die gleiche Operation auf unterschiedliche Datentypen ausgeführt in zwei unterschiedlichen Prozeduren münden muss. Dies führt zu einer Codeduplikation, die den Wartungsaufwand, der besonders bei großen Softwareprojekten einen erheblichen Teil der Kosten ausmacht, erhöht.
Ebenso bietet das imperative Paradigma keinerlei Zugriffskontrolle über die Daten und jede Prozedur ist erst einmal gleichberechtigt alle Daten, für die sie einen Zeiger erhaschen kann, zu manipulieren. Dies erfordert, gerade wenn viele Entwickler an der gleichen Quellcodebasis arbeiten, ein enormes Maß an Disziplin, welches erlernt und eingehalten werden muss.
Zum letzten bietet das rein imperative Paradigma kein Konzept zur Bündelung mehrerer semantisch zusammenhängender Prozeduren. Sicherlich gibt es die Möglichkeit, Prozeduren, die zusammen gehören, ähnlich zu benennen. Aber auch das erfordert Disziplin von den Entwicklern. Ab einer gewissen Größe wird die Menge aller Prozeduren zu einem großen See, in dem man keinerlei Struktur mehr erkennen kann.
Was man bräuchte, wäre eine zweite Art von Strukturkonzept für Codeorganisation. Teilweise kann dies durch Module bewerkstelligt werden, aber auch Objektorientierung bietet hier Konzepte an.

Wie der Name schon vermuten lässt, stellt die Objektorientierung (OO) nicht mehr die Prozedur in den Mittelpunkt, sondern das Objekt.
Vergleichen wir Objekte und Prozeduren mit der natürlichen Sprache, so kommen wir zur Analogie, dass Objekte wie Nomen und Prozeduren wie Verben sind.
Die Konzentration von OO auf Objekte verschiebt somit den Fokus vom "was getan wird" zu einem "wem" getan wird.
Auf den Folien zeige ich ein Beispiel, welches verdeutlicht, dass diese Verschiebung zu intuitiveren Programmstrukturen führen kann.
Bei Konzentration auf Verben würden wir "Apfel waschen" und "Fahrrad waschen" in der gleichen Kategorie verorten, es wird ja schließlich etwas gewaschen.
Nun sind beide Reinigungstätigkeiten zwar ähnlich, haben aber in ihren Werkzeugen und ihrem Ziel nur sehr wenig miteinander zu tun.
Anders sieht es aus, wenn wir und auf die Nomen konzentrieren und unser Fahrrad in den Mittelpunkt stellen.
An diesen zentralen Begriff hängen wir dann die Verben an, die zu diesem Objekt passen:
"waschen" und "fahren".
Und schon haben wir, durch die Verschiebung des Fokuspunktes, eine Organisation gefunden, die viel mehr den menschlichen Erfahrungen entspricht, die die Welt eher nach ihren Objekten und weniger nach ihren Operationen sortiert.

Die Grundidee von OO ist das Objekt als eigenständige Entität zu sehen, das eine Menge von Eigenschaften hat und über **Methoden** mit anderen Objekten interagiert. Dieses Mitdenken der Methoden als Teil des Objekts ist ein anderer Objektbegriff als der, den wir in Vorlesung "06 - Objekte" gebraucht habe. Denken Sie also für diese Vorlesung beim Begriff Objekt immer ein implizites "OO-" Präfix dazu. 


#+begin_src latex
  \begin{frame}{Nachrichten und Objekte}
    \begin{center}
      \includegraphics[width=0.7\textwidth]{fig/11-messages}    
    \end{center}

    \begin{btBlock}{Definition nach Alan Kay (Erfinder von Smalltalk)}
      \small
      \be
      \ii \structure{Messaging}: Objekte kommunizieren durch den Versand von Nachrichten.
      \ii \structure{Persistenz}: Objekte haben privaten Zustand, auch wenn sie nicht aktiv sind.
      \ii \structure{Kapselung}: Informationen werden im Objekt verborgen.
      \ii \structure{Späte Bindung}: Ausgeführte Operation wird möglichst spät ausgewählt.
      \ee
    \end{btBlock}
  \end{frame}

  \begin{frame}{Konzepte für Objektorientierung}
    \btAnimation[height=7cm]{range=3-5:<1->,center,padding=1ex}{fig/11-the-object}
  \end{frame}


  \begin{frame}<handout:4>[fragile]{Die Methode als die zentrale Erweiterung}
    \bi
    \ii Methoden haben einen \structure{Ausführungskontext} mit dem Objekt{
      \bi
      \ii Objekt, auf dem die Methode aufgerufen wird, wird sichtbar.
      \ii Objektattribute sind in der Methode zugreifbar.
      \ii Methode ist eine Closure! (Siehe \enquote{03 - Namen})
      \ei
    }\medskip
    \ii \structure{Closure}: Eine Prozedur, die einen Ausführungskontext mitbringt\\ {
      \bgroup\btAnimation[width=0.8\textwidth]{1:<1-2>,2:<3>,3:<4>,center,padding}{fig/11-closure}\egroup
      \bi
      \ii Prozeduren werden \textbf{immer} in einem Kontext ausgeführt.
      \ii Bei C sind nur die Argumente und die globalen Variablen enthalten.
      \ii Bei Closures sind zusätzliche Objekte an Namen gebunden (z.B. \structure{\texttt{this}}).
      \ei
    }
    \ei
  \end{frame}
#+end_src

Wie wir bereits gesagt haben, stehen beim objektorientierten Paradigma die (OO-)Objekte im Mittelpunkt. Um dies noch etwas genauer zu fassen, wollen wir uns die Definition von Objektorientierung von Alan Kay, dem Erfinder von Smalltalk, der ersten objektorientierten Programmiersprache, anschauen.

Für Kay ist das wichtigste Element von OO das **Messaging** zwischen Objekten. Anstatt Prozeduren mit Argumenten aufzurufen, findet alle Interaktion über Nachrichten statt. Objekte schicken anderen Objekten Nachrichten, welche auf diese Nachrichten reagieren. Technisch umgesetzt werden diese Nachrichten mittels Methodenaufrufe, aber das mentale Bild soll sein, dass einzelne Objekte anderen Objekten eine Nachricht schicken. Denken Sie dabei nicht an Netzwerknachrichten, sondern an etwas Abstrakteres. Das Firmenobjekt schickt dem Arbeiter eine Nachricht mit der nächsten Aufgabe.
In Java ist dies durch, die dem Objekt angehängten, Methoden implementiert.

Der zweite Aspekt von OO ist die **Persistenz** des privaten Objektzustandes. Objekte repräsentieren eigenständige Entitäten und haben einen internen Zustand, selbst wenn sie gerade keine Nachricht verarbeiten. Technisch gesehen bedeutet dies, dass die Eigenschaften des Objekts im Speicher residieren müssen, um über Methodenaufrufe hinweg Zustand zu halten. Dabei hat jedes Objekt seinen **eigenen** privaten Zustand.
In Java ist dies durch Objekteigenschaften implementiert{{{see(03-composite-types,Zusammengesetzte Typen)}}}.

Für Kay ist der dritte Prüfstein von OO, dass die Eigenschaftes des Objekts im Objekt selbst gekapselt sind und nicht von außen zugegriffen werden können.
Dabei stellen die Methoden des Objekts das "Innen" dar, und jeglicher andere Code das "Außen".
Hier zeigt sich die klare Erweiterung von OO-Objekten gegenüber Records, die ja von überall zugreifbare Felder beinhalten.
Durch diese Kapselung wird im Code ganz klar, welcher Code einzelne Eigenschaften eines Objekts lesen und verändern darf.
In Java ist dies durch die Feldmodifier ~private~, ~protected~ und ~public~ implementiert{{{see(04-limited-visibility,Einschränkung der Sichtbarkeit)}}}.

Der letzte Aspekt von OO ist für Alan Kay die späte Bindung von Nachrichten an Operationen.
Dies bedeutet, dass nicht bei Versenden einer Nachricht entschieden wird, welcher Code tatsächlich ausgeführt wird, sondern erst beim Empfang der Nachricht durch ein Objekt.
Auf diese Weise kann bei OO jedes Objekt unterschiedlich auf gewissen Nachrichten reagieren.
In Java ist dies durch Methoden mit virtuellen Dispatch anhand des dynamischen Typs implementiert {{{see(04-dynamic-dispatch,Überladung und Polymorphismus)}}}.

Gegenüber dem imperativen Paradigma ist die **Methode** das entscheidende ***neue Sprachkonzept**.
Anstatt Prozeduren und Objekte getrennt voneinander zu halten, sind Methoden Prozeduren, die zu einem bestimmten Objekt gehören.
Auf diese Weise wird der Empfang einer Nachricht durch ein Objekt zu einem Methodenaufruf auf dem entsprechenden Objekt.
Innerhalb der Methode ist das angebundene Objekt sichtbar ohne vom Aufrufendem als Argument mitgegeben zu werden.
Sie kennen dieses Verhalten zum Beispiel bereits aus Java, wo innerhalb einer Methode die Felder des Objekts und das Objekt selbst (als ~this~) sichtbar sind.
In Python ist dieses Sichtbarmachen des Objekts noch deutlicher, da Methoden einen ~self~-Parameter haben, der allerdings nicht als Argument angegeben werden muss.

Um das Kernkonzept der Methode drapieren sich noch die anderen Konzepte, mit denen die von Kay geforderten Eigenschaften in OO-Sprachen implementiert werden. Durch Zugriffsmodifier können wir die Sichtbarkeit von Feldern einschränken und so Kapselung erreichen. Durch dynamischen Dispatch/virtuelle Methodenaufrufe wird das späte Binden implementiert.

Was auf den Folien noch dazu kommt, was aber in gewisser Weise nicht, wie wir sehen werden, in den vier essentiellen Punkten von Kay enthalten ist, ist das Konzept von Subtyp-Polymorphie durch Vererbung{{{see(03-polymorphism,Polymorphismus)}}}. Denn Kay spricht nur davon, wie sich Objekte zu verhalten haben, er macht aber keine Aussage darüber, wie diese Objekte ins Leben treten und wie wir Prozeduren als Methoden an ein Objekt binden. Bei Vererbung geschieht dies durch eine hierarchische Beziehung von Record-Typen, die in einer Subtyp-Beziehung zueinander stehen und in eine Richtung durcheinander ersetzbar sind. Im nächsten Unterkapitel werden wir jedoch die prototypenbasierte Objektorientierung kennenlernen, die gänzlich ohne separate Klassen auskommt und alles über einen Objektbau abhandelt. Seien Sie also gespannt.

Aber zurück zu den Methoden.
Technisch gesehen sind Methoden Closures{{{see(04-call-frames,Function-Call Frames)}}}, also eine Kombination einer Prozedur mit einem (teilweise) gebundenem Ausführungskontext.
Um dies zu verstehen bedarf es noch einer Diskussion des Ausführungskontextes:
Innerhalb einer Prozedur werden Referenzen zu Variablen über den Ausführungskontext aufgelöst.
In einer C-Funktion beinhaltet dieser Ausführungskontext die gebundenen Parameter und die lokalen Variablen der aktuellen Funktionsinstanz.
Zusätzlich sind aber auch alle globalen Variablen im Ausführungskontext einer C-Funktion und zwar über Funktionsinkarnationen hinweg.
In C haben wir also nur zwei Ebenen von hierarchisch Ausführungskontext: den lokalen der Funktionsinstanz (für jeden Aufruf ein neuer Kontext) und den globalen Kontext (immerwährend).

Für OO müssen wir uns einen dritten dazwischenliegenden Kontext vorstellen, in dem das aktuelle Objekt (und teilweise dessen Felder) gebunden sind. Bei der Namensauflösung{{{see(04-implicit-resolution,CNSR)}}} werden diese Kontexte (zur Laufzeit!) von innen nach außen durchsucht, bis der Variablenname zum gebundenen Objekt aufgelöst werden kann.
Durch diesen erweiterten Ausführungskontext ist eine Methode etwas wirklich anderes als eine Prozedur. Denn im Gegensatz zur Prozedur hat die Methode eines Objekts einen Zustand, nämlich die persistent gespeicherten Eigenschaften des Objekts.
Technisch löst der Übersetzer diesen erweiterten Ausführungskontext effizient durch einen impliziten ~this~-Parameter. Aber das haben wir nun wirklich schon oft genug in diesem Skript erklärt. Kommen wir also wieder mal zu etwas ganz neuem: Prototypen.

** Prototypenbasierte Objektorientierung
:PROPERTIES:
:CUSTOM_ID: 11-prototype-oo
:END:
#+begin_src latex
\dividerframe{Prototypen}
  \begin{frame}{Objektorientierung ohne Klassen}
    \begin{btBlock}{}
      Da Sie alle OO auf Basis von Klassen zur Genüge kennen, werden wir eine andere Art der OO Programmierung betrachten.
    \end{btBlock}
    \medskip
    \bi
    \ii Javascript kennt \ALERT{keine Klassen} und ist \ADVANTAGE{dennoch} objektorientiert{
      \bi \def\C{\bgroup\textcolor{safegreen}\checkmark\egroup}
      \ii Javascript-Objekte haben Attribute (\C) und gebundene Methoden (\C)
      \ii Methoden werden erst beim Aufruf aufgelöst (\C)
      \ii Informationen können mittels lexikalischem Scoping verborgen (\C) werden
      \ei
    }\medskip
    \ii JavaScript verwendet \structure{prototypenbasierte Vererbung}{
      \bi
      \ii Flexibler, erweiterbarer, und mächtiger als klassenbasierte Vererbung
      \ii Hohe Dynamik, die besonders für eine Skriptsprache geeignet ist
      \ii Wenige Sprachmechanismen, aber ein gewisser Zoo an syntaktischem Zucker
      \ei
    }
    \ei
  \end{frame}

  \begin{frame}<handout:1,3>[fragile]{JavaScript: Die Prototypenkette}
    \begin{columns}
      \hfill
      \begin{column}{0.49\textwidth}
        \begin{code}[]
          \begin{JS}
            var obj = { a: 23 };
            obj.zz = 42;
            [obj.a, obj["a"], obj["zz"]];
            // => [23, 23, 42]
          \end{JS}
        \end{code}
      \end{column}\hfill
    \end{columns}

    \bi
    \ii JavaScript-Objekte sind \emph{\enquote{bags} of properties}{
      \bi
      \ii Zugriff über \texttt{[]} und den Punktoperator
      \ii Recordtyp und Abbildungstyp fallen zusammen
      \ii Properties können zu einem Objekt hinzugefügt werden
      \ei
    }\medskip
    \ii<handout:2-|2-> \texttt{\_\_proto\_\_}: Fallback für die Suche nach Attributen{
      \bi
      \ii Situation: Ein Objekt hat das geforderte Attribut nicht.
      \ii Die Suche wird beim Prototypen, der in \texttt{\_\_proto\_\_} referenziert ist, fortgesetzt.
      \ii Es entsteht die \structure{Prototypenkette}, die bei \texttt{\{\}} endet.
      \ei\smallskip
      \btAnimation[width=0.9\textwidth]{1:<1-2>,2:<3>,center,padding}{fig/11-prototypes}
    }
    \ei
  \end{frame}
#+end_src

Da Sie klassenbasierte Objektorientierung aus Java ja bereits kennen, will ich Sie nicht weiter damit langweilen, Ihnen Vererbung mittels Klassen noch einmal zu reiterieren. Anstatt dessen wollen wir uns **prototypenbasierte Objektorientierung** als eine andere Geschmacksrichtung von OO anschauen, die, wie ich finde, sogar die geforderten 4 Eigenschaften noch deutlicher macht, als dies bei klassenbasierter OO der Fall ist. Als Beispiel werden wir uns  Prototypen-OO in JavaScript, da diese Sprache auf wirklich jedem modernen Gerät im Browser zur Verfügung steht.

Vorneweg, JavaScript unterstützt im Kern keine Klassenbasierte OO, sondern nur Prototypen-OO, obwohl es inzwischen Syntaxzucker gibt, der es so erscheinen lässt als hätte JavaScript Klassen. Diese in [[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes][ECMAScript 2015]] eingeführte Syntax ist am Ende nur ein ganz dünnes Furnier über der eigentlichen prototypenbasierte JavaScript OO Engine. Wir schauen uns daher nur diese unterliegende Schicht an, in der JavaScript die vier geforderten Eigenschaften von Kay erfüllt.

Generell kann man sagen, dass Prototypen-OO flexibler ist als klassenbasierte OO, da man zur Laufzeit die Methoden und Eigenschaften von bereits erzeugten Objekten verändern kann.
Dies ist nur möglich, da JavaScript im Herzen eine im Interpreter dynamisch ausgeführte Skriptsprache ist, auch wenn es heutzutage Just-in-Time Übersetzer gibt, die JavaScript im Browser zu schnell ausführbaren Maschinencode übersetzt.
Um Prototypen-OO in Javascript zu verstehen, muss man zwei Sprachmechanismen verstehen: Die *Prototypenkette* und den JavaScript-**Methodenaufruf**.

Schauen wir uns zunächst JavaScript-Objekte und die Prototypenkette an.
Die erste wichtige Eigenschaft von JavaScript ist, dass Record- und Abbildungstypen zusammenfallen.
In JavaScript ist alles drei einfach ein ~object~.
Diese JS-Objekte können als Sack voller Attribute beschrieben werden, die über einen dynamisch generierten Key abgerufen werden können.
Daher hat JavaScript zwei semantisch äquivalente Notationen, um auf Attribute zuzugreifen:
~obj.a~ und ~obj["a"]~ bedeuten exakt das gleiche und greifen auf das Attribut ~a~ des Objekts zu.
Wir können, wie wir auf den Folien sehen, sogar Attribute zu einem bereits existierenden Objekt hinzufügen (~obj.zz~).
Ein leeres Objekt, ohne Attribute, kann in JavaScript einfach über ~{}~ erzeugt werden und dann mit neuen Attributen ausgestattet werden.

#+begin_src javascript
var obj = { a: 23 };
obj.zz = 42;
[obj.a, obj["a"], obj["zz"]];
#+end_src


Die **Prototypenkette** setzt an diesen Objekten an, indem /jedes/ Objekt eine interne Eigenschaft ~__proto__~ hat, die auf ein anderes Objekt verweisen kann (oder ~null~ ist, um die Kette abzubrechen).
Das so referenzierte Objekt wird dann als Fallback für die Suche nach Attributen benutzt: Wenn wir mit dem Punktoperator (~objekt.attribut~) nach einem Attribut suchen, wird zuerst in den **eigenen Attributen** des Objekts gesucht. Hat das Objekt das gesuchte Attribut nicht selbst, so wird die Suche bei dem Objekt, was mittels ~__proto__~ als Prototyp angegeben ist, fortgesetzt. Dort wird die Suche dann noch weiter nach oben Eskaliert, bis das Attribut gefunden wurde oder die Prototypenkette abbricht (~null~).

#+begin_src javascript
var x = {a: 23};
x.__proto__.b = 42;
[x, x.__proto__, [x.a, x.b]]
#+end_src

Durch diesen Mechanismus der Prototypenkette können dynamisch komplexe Vererbungsbeziehungen zwischen Objekten entstehen (es sind keine Klassen involviert):
Objekte, die als Prototypen referenziert sind, vererben ihre Attribute dynamisch an alle Kinder, ohne deren Datenlayout zu verändern.
Fügt man zu so einem Objekt, das weit oben in der Prototypenkette steht, ein Attribut hinzu, "erben" alle Objekte, die direkt oder indirekt auf dieses Objekt verweisen, das Attribut.
Die einzige Ausnahme ist, dass ein Objekt das Attribut selbst als eigenes Attribut hat, da in diesem Fall die Attributsuche abgebrochen wird, bevor wir zum Prototypenobjekt kommen.

Da in JavaScript alle Objekte gleichberechtigt sind, gibt es keine Unterscheidung zwischen Klassen und Objekten. Jedes Objekt kann als Prototyp für eine ganze Reihe von anderen Objekten stehen. Insgesamt bilden so alle JS-Objekte einen großen Prototypen-Baum, mit dem leeren Objekt (~{}~) als Wurzel. Man kann sogar durch ~({}).__proto__.x = 42~ jedem existierenden Objekt das Attribut ~x~ unterschieben (Die Klammern braucht man, damit der Parser nicht hustet).

  #+begin_src latex
  
  
  \begin{frame}[fragile]{JavaScript: Attribut-Lookup und \texttt{this}}
    \bi
    \ii Prototypenkette implementiert dynamischen und hierarchischen Lookup{%
      \bi
      \ii Objekt in der Kettenmitte erweitern $\rightarrow$ Alle Kinder werden erweitert
      \ii Speichereffizient, aber mit höheren Lookup-Kosten verbunden
      \ei
    }\medskip
    \ii<2-> JavaScript bindet den Namen \structure{\texttt{this}} an das aktuelle Objekt{
      \bi
      \ii Attribute können auf Funktionen verweisen
      \ii Objekt-Attribut als Funktion aufrufen $\Rightarrow$ \texttt{this} wird an das Objekt gebunden
      \ei
    }
    \ei
    \begin{columns}<2->
      \begin{column}{0.49\textwidth}
        \begin{code}[tag=JavaScript]
          \begin{JS}[]
            var obj = {
              prop: 37,
              f: function() {
                return this.prop;
              }
            };
            var ff = obj.f;
          \end{JS}
        \end{code}
      \end{column}\hfill
      \begin{column}{0.49\textwidth}
        \bii
        \ii Aufruf der Funktion als Attribut\\
            \codeinline{obj.f()} $\Rightarrow$ \codeinline{37}\\[2ex]
        \ii Aufruf der \enquote{blanken} Funktion\\
            \codeinline{ff()} $\Rightarrow$ \codeinline{undefined}
        \eii
      \end{column}
    \end{columns}
  \end{frame}

  \begin{frame}[t,fragile]{JavaScript: Funktionen als Konstruktoren}
    \bi
    \ii \textbf{Alle} Funktionen können als Konstruktoren verwendet werden{
      \bi
      \ii Das Schlüsselwort \structure{\texttt{new}} ruft Funktion im Kontext eines neuen Objekts auf
      \ii Jede Funktion hat ein \structure{\texttt{.prototype}}-Attribut, das als \texttt{\_\_proto\_\_} gesetzt wird.
      \ei
    }
    \ei

    \begin{columns}[t]
      \begin{column}{0.49\textwidth}
        \begin{code}[]
          \begin{JS}
            function Foo(name) {
              this.name = name;
            }
          \end{JS}
          \begin{onlyenv}<handout:2-|2->
          \vspace{1em}
          \begin{JS}
            var obj = new Foo("alice");
          \end{JS}
        \end{onlyenv}%
        \begin{onlyenv}<handout:3-|3->\vspace{1em}
            \begin{JS}
            Foo.prototype.getLength = \
              function() {
                return this.name.length;
              };

            obj.getLength() // => 5
          \end{JS}
        \end{onlyenv}
      \end{code}%
      \begin{onlyenv}<2|handout:2>
        \begin{center}
          dies ist äquivalent zu
        \end{center}
        \begin{code}
          \begin{JS}<3-|handout:3->
            var obj = {
              __proto__: Foo.prototype
            }
            // Aufruf mit this == obj
            obj.constructor("alice");
          \end{JS}
        \end{code}
      \end{onlyenv}

      \end{column}\hfill
      \begin{column}{0.49\textwidth}\centering
        \btAnimation[width=2.7cm]{raisebox,range=1-3:<1->,3:<4>}{fig/11-js-constructors}
      \end{column}
    \end{columns}
    \bi
    \ii<4-|handout:4-> Modernes JavaScript bietet \structure{\texttt{class}} und \structure{\texttt{extends}} als syntaktischen Zucker
    \ei
  \end{frame}

  \begin{frame}{Prototypenbasierte Objektorientierung}
    \bi
    \ii Objekte erben alle Eigenschaft ihrer Prototypen {
      \bi
      \ii JavaScript: Dynamischer Lookup entlang der Prototypenkette
      \ii Konstruktion der Prototypen-Hierarchie mittels \structure{\texttt{new}}
      \ii Sieht aus wie klonen, ist aber effizienter.
      \ei
    }\medskip
    \ii Alle Objekte sind \structure{gleichberechtigt} und können Prototypen werden {
      \bi
      \ii Keine Unterscheidung zwischen Objekten und Klassen
      \ii JavaScript: \texttt{obj.\_\_proto\_\_} zeigt wieder auf ein Objekt
      \ii Es entsteht ein Baum von Objekten, die Prototypen füreinander sind.
      \ii Die Wurzel des Baums ist das leere Objekt: \texttt{\{\}}
      \ei
    }\medskip
    \ii Veränderung eines Prototypen ändert alle erbenden Objekte {
      \bi
      \ii JavaScript: Eingebaute Objekte können erweitert werden (discouraged)
      \ii \codebox{Array.prototype.forEach = function(...) \{ ... \}}
      \ii Alle Objekte können jetzt \texttt{forEach}: \codebox{[2,3,4].forEach(...)}
      \ei
    }
    \ei
  \end{frame}
#+end_src

Durch die Prototypenketten können wir relativ speichereffizient einer Vielzahl an Objekten dynamisch Attribute hinzufügen. Allerdings kostet uns diese Speichereffizienz und die Dynamik und Flexibilität der Attribut-Lookups Laufzeit. Im Zweifel muss ja jeder Attributzugriff durch das Abgehen der gesamten Prototypenkette aufgelöst werden. Für eine Skriptsprache ein valider Trade-Off zwischen Flexibilität und Laufzeit; für eine übersetzte Sprache würden wir uns zweimal überlegen ein solches Feature einzubauen.

Der zweite Mechanismus, mit dem JavaScript dann endgültig zur OO Sprache wird, ist die Art und Weise, wie der **Methodenaufruf** geschieht. Vorneweg muss man erklären, dass in JavaScript Funktionen an jeder Stelle erzeugt (~var FUN = function () { return 23;};~) und auch wieder aufgerufen werden können (~FUN()~). Daher können Funktionen auch in  Objekt-Attributen gespeichert werden. Die Magie geschieht in JavaScript an der Stelle, an der eine Funktion als Attribut eines Objekts aufgerufen wird (~obj.f()~). In diesem Fall wird die Funktion mit einem Ausführungskontext aufgerufen, in dem die Variable ~this~ an das Objekt gebunden ist. Extrahiert man die Funktion zuerst und ruft sie anderweitig auf (~var ff = obj.f; ff()~), greift dieser Mechanismus nicht!

Durch diese Art des Methodenaufrufs kann jede Funktion zu einer gebundenen Methode werden, indem man sie als Attribut des Objekts speichert. Zusammen mit der Prototypenkette kommt man dann schnell dazu, dass es möglich ist, solche Methoden zu vererben, indem man eine Funktion als Attribut eines Prototypen-Objekts setzt. Bei der Attributsuche wird dann die Prototypenkette nach oben abgegangen, die Funktion extrahiert und mit gebundenem ~this~ (auf das originale Objekt) aufgerufen. Fertig ist der virtuelle Methodenaufruf, dessen Bindung zum Zeitpunkt des Aufrufs stattfindet (siehe Späte Bindung).

Da das manuelle Aufbauen einer Prototypenkette eher mühsam ist, bietet JavaScript noch einige Mechanismen, die es uns erleichtern, diese Art der Objektorientierung zu verwenden. Eine davon ist die Verwendung von **Funktionen als Konstruktoren**: Für jedes Funktionsobjekt (~Foo~), das wir anlegen, wird zusätzlich ein Prototypenobjekt (~Foo.protoype~) angelegt, welches ein Attribut ~constructor~ hat, welches (zyklisch) auf die Funktion zeigt.

Die Instantiierung und Initialisierung von neuen Objekten geschieht über den ~new~-Operator, den man einem normalen Funktionsaufruf vorwegstellt: Zuerst erzeugt der Operator ein leeres Objekt und setzt das ~__proto__~-Attribut auf ~Foo.prototype~, womit es alle Attribute, inklusive ~.constructor~ erbt. Danach wird ~obj.constructor~, also die tatsächliche Funktion, aufgerufen. Da diese als ein Attribut aufgerufen wird, startet sie mit einer passend gebundenen ~this~ Variable, über die sie das neue Objekt initialisieren kann.

Erweitert man den Prototypen (~Foo.prototype~), kann man alle Objekte, die über ~new Foo(...)~ erzeugt wurden, um neue Attribute und Methoden erweitern. Dies funktioniert sogar mit eingebauten Objekten wie ~Array~ oder ~String~, wird aber von der JavaScript-Community nicht empfohlen (siehe Prinzipien).

Wenn wir alles zusammenfassen (Prototypenkette, Methodenaufruf und Funktionen als Konstruktoren), so sehen wir, dass JavaScript eine vollständige objektorientierte Programmiersprache ist, die allerdings ganz ohne Klassen auskommt.
Vielmehr sind alle Objekte gleichberechtigt und einzig ihre dynamisch änderbare Position in der Prototypenkette bestimmt ihre Rangordnung in der Vererbungshierarchie.
Dies ist sehr flexibel, kann aber auch leicht dazu führen, dass man sich gewaltig in den Fuß schießt.
Daher hat JavaScript inzwischen syntaktischen Zucker (~class~, ~extends~), um klassenbasierte (Einfach-)Vererbung sauber abzubilden.
Was allerdings mit Prototypen-OO nicht abbildbar ist, ist Mehrfachvererbung, da jedes Objekt nur einen Vorgänger in der Prototypenkette hat.


** Kritikpunkte am objektorientierten Paradigma
:PROPERTIES:
:CUSTOM_ID: 11-oo-critique
:END:

#+begin_src latex
  \dividerframe{Kritik am objektorientierten Entwurf}

  \begin{frame}<handout:1,3>[fragile]{Konzentration auf Objekte}
    \bi
    \ii Objektorientierte Entwurfsmethoden fokussieren Objekte {%
      \bi
      \ii \structure{Verb/Nomen-Analyse} von Use-Case-Beschreibungen\\[1ex]
          Alle Nomen werden Klassen/Objekte.\hspace{1em} Alle Verben werden Methoden.\\[2ex]
     \ii Arbeiter (Nomen) montiert (verb) Reifen (Nomen) an Auto (Nomen).\\[2ex]
          \begin{center}
          \begin{tikzpicture}
            \node[rectangle split, rectangle split parts=2,draw] {%
              Arbeiter
              \nodepart{two}%
              void montieren(Reifen, Auto)
            };
          \end{tikzpicture}
        \end{center}
        \ei
      }\bigskip
      \ii<2-> \ALERT{Kritik}: Objektorientierung vernachlässigt Verben {\\[1ex]
        \begin{displayquote}[Steve Yegge, Execution in the Kingdom of Nouns][\hfill]
          Object Oriented Programming puts the Nouns \alert{first and foremost}. Why would you go to such lengths to put one part of speech on \textbf{a pedestal}? Why should one kind of concept take precedence over another? It's not as if OOP has suddenly made verbs \alert{less important} in the way we actually think.
        \end{displayquote}
      }
      \ei
    
    \overlayboxHBOX
    \begin{overlaybox}<handout:3-|3->[draw=srared,ultra thick]
      \includegraphics[height=5cm]{fig/11-hund}
    \end{overlaybox}
  \end{frame}

  \begin{frame}[fragile]{Konzeptionell: Verben kommen nie allein!}
    \bi
    \ii Nicht jede Funktionalität kann einem Objekt zugeordnet werden. {
      \bi
      \ii Zu welchem Objekt gehört der Algorithmus \textbf{größter gemeinsamer Teiler}?
      \ii Methode von \texttt{AlgorithmManager}-Klasse?  Unterschiedliche Instanzen?
      \ii Gehört sie zur Klasse \texttt{int}? Hat \texttt{BigInt} eine eigene \texttt{gcd()} Methode?
      \ii[$\Rightarrow$] \textbf{\enquote{Lösung}}: Nicht-instantiierte Klassen die nur statische Methoden beinhalten\\[1ex]
      \begin{center}
        \codebox{void java.lang.Math.sin(double a);}
      \end{center}
      \ei
    }\bigskip
    \ii<2-> Wir können keine blanken Funktion herumreichen {
      \bi
      \ii Callback-Funktionen müssen immer von einem Objekt \enquote{bewacht} werden
      \ii[$\Rightarrow$] Leere Objekte, die nur eine Methode \enquote{\texttt{execute()/run()/do()}} haben{
        \begin{center}
          \codebox{void java.lang.Runnable.run();}
        \end{center}
      }\medskip
      \ii \structure{Designpatterns}, um diese Schwäche zu umschiffen: Command, Strategy, Proxy
      \ei
    }
    \ei
  \end{frame}

  \begin{frame}{Konzeptionell: Daten kommen nie alleine!}
    \bi
    \ii Von manchen Klassen kann es nur eine Instanz geben {
      \bi
      \ii Manche Entitäten sollten in einem Programm nur einmal existieren.
      \ii Beispiel: Managerobjekt, das \textbf{alleinige} Kontrolle über einen Aspekt hat
      \ii \structure{Designpattern}: Singleton (nur möglich durch statische Attribute)
      \ei
    }\bigskip
    \ii<2-> Strikte Objektorientierung kennt keinen \structure{globalen Kontext} {
      \bi
      \ii An welchem Objekt würde eine globale Variable hängen? 
      \ii Globale Variablen erlauben globale Konfiguration des Programmverhaltens\\[1ex]
      \ii[$\Rightarrow$] Durchschleifen von Kontext-Objekten mit Programmoptionen\\[2ex]{
        \hspace{1cm}%
        \btSetTab\codebox{void app.grep.Searcher.search(ProgramContext);}\\
        \btUseTab\codebox{void app.grep.Searcher.iterateDirectory(ProgramContext, Directory);}\\
        \btUseTab\codebox{void app.grep.Searcher.processFile(ProgramContext, String);}\\
          \btUseTab\codebox{void app.grep.Searcher.searchLine(ProgramContext, String);}\\
      }\medskip
      \ii \structure{Designpatterns}, die dieses Problem beheben: Registry, ServiceLocator\\
      \hfill\scriptsize(Beides Singletons)
      \ei
    }
    \ei
  \end{frame}

  \begin{frame}{\enquote{Objektorientierung ist ineffizient!}}
    \bi
    \ii OO-Entwurfsprinzipien verleiten, Probleme zu feinschichtig zu zerlegen{\\[1ex]
      \begin{center}
        \includegraphics[page=1,height=1.8cm]{fig/11-call-hierarchy}\hspace{2cm}
        \includegraphics[page=2,height=1.8cm]{fig/11-call-hierarchy}
      \end{center}

      \bi
      \ii Verteilung der Verantwortlichkeit auf viele Objekte
      \ii Unübersichtlicher Kontrollfluss zwischen den einzelnen Methoden
      \ii Viele Methodenaufrufe zwischen den Schichten
      \ei
    }\medskip
    \ii<2-> Hohe Kosten für den einzelnen  Methodenaufrufe{
      \bi
      \ii \structure{Späte Bindung}: Dynamic Dispatch wählt Methode zur Laufzeit aus
      \ii \structure{this}: Der implizite durchgeschleifte Parameter ist nicht umsonst.
      \ei
      \medskip
      \begin{displayquote}[Joe Armstrong, Erlang Erfinder][\\\hfill]\small
        The problem with object-oriented languages is they've got all this implicit environment that they carry around with them. You wanted a banana but what you got was a gorilla holding the banana and the entire jungle.
      \end{displayquote}
    }
    \ei
  
    \overlayboxHBOX
    \begin{overlaybox}<handout:3-|3->[draw=srared,ultra thick]
      \includegraphics[height=8cm]{fig/11-callstack}
    \end{overlaybox}
  \end{frame}
#+end_src

Bevor wir mit der Diskussion des objektorientierten Paradigmas zum Ende kommen, und in Vorbereitung der nächsten Vorlesung, will ich noch einige Kritikpunkte aufgreifen, die an diesem Paradigma geäußert worden sind.
Diese Kritik ist dabei selten am Paradigma selbst, sondern mehr auf die Prinzipien seiner Verwendung, gerichtet.
Dennoch fußen ja all diese Prinzipien auf den Mechanismen, die wir im OO Paradigma vereinigt haben und daher lohnt es sich an dieser Stelle, einen Blick auf die Kritik zu werfen.

Um diese Kritik zu verstehen, muss man sich kurz die Grundüberlegung von OO vor Augen halten: Alle Entitäten sind Objekte, die Nachrichten austauschen. OO legt also einen großen Fokus auf die Objekte, was sich auch in der OO Entwurfsmethode der **Verb/Nomen-Analyse** niederschlägt. Diese wird verwendet, um Software objektorientiert zu entwerfen. Dazu nimmt man sich definierte Use-Cases zur Hand und markiert sich alle Nomen und alle Verben, die sich auf diese Nomen beziehen. Ganz grob vereinfacht sagt man dann, dass alle Nomen Objekte/Klassen werden und die Verben, untergeordnet, als Methoden an diese Objekte gehangen werden. Ich werde das hier nicht tiefer ausführen, da es eigentlich ein Thema des Software Engineering ist. Was wir allerdings in dieser Entwurfsmethodik sehen, ist, dass die Verben den Nomen untergeordnet werden.

Der erste, relativ philosophische, Kritikpunkt zielt dann auch genau darauf ab, dass Verben vernachlässigt werden: Durch die OO Designphilosophie haben wir uns jahrelang nur auf die Objekte versteift und Software danach gebaut, wie wir Alles einzelnen Objekten zuordnen können. Aber deswegen sind Verben, also Tätigkeiten bzw. Aktionen, ja nicht weniger wichtig geworden. Allerdings zwingt uns das objektorientierte Paradigma dazu, jedenfalls wenn man es konsequent durchzieht, dass Tätigkeiten (Verben) niemals alleine auftreten können. Sondern sie werden gewissermaßen immer von einem Objekt an der Leine geführt. Aus dieser gezwungenen Kopplung ergeben sich dann auch die anderen Kritikpunkte, die man am OO Paradigma anbringen kann.

So stellt sich bei manchen Aktionen (wir nennen sie dann mal wieder Funktionen) die Frage, zu welchem Objekt sie gehören sollen.
An welchem Objekt sollte denn die Funktion "größter gemeinsamer Teiler" hängen?
Sollte es eine Methode von "Integer" sein?
Was ist dann mit anderen Objekten, die sich auch wie eine Ganzzahl verhalten, aber in keiner Vererbungsbeziehung zu Integer stehen (z.B.
BigInt).
Sollte die ihre eigene Implementierung für ~gcd()~ mitbringen?
Und was sollte jemand tun, der sich einen neuen Algorithmus überlegt, der Ganzzahlen verarbeitet?
In Java kann man ja von außen nicht einfach eine Methode an eine bereits definierte Klasse ranflanschen.
Das ist alles schwierig.
Daher wählt man für dieses Problem häufig die Lösung über Klassen, die nur **statische Methoden** beinhalten.
Diese Klassen dienen nur als Container für statische Methoden, sollen aber nie instantiiert werden.
Das Paradebeispiel dafür ist Javas ~java.lang.Math~-Klasse, die alle wichtigen mathematischen Funktionen beinhaltet.
An diese Stelle werden die Prinzipien des objektorientierten Designs absichtlich umgangen, indem die Konzepte des objektorientierten Paradigmas missbraucht werden.
Dieses Muster, dass Konzepte, die anders verwendet werden sollen, missbraucht werden, um Probleme mit den Designprinzipien zu umgehen, werden wir noch häufiger sehen.
Oft genug nennen wir diese kreativen Lösungen dann **Designpattern** und schreiben Bücher darüber.

Ziemlich ähnlich zum letzten Problem ist das Herumreichen von blanken Funktionen.
Da eine Methode immer an einem Objekt hängt, können wir nicht einfach einen Funktionszeiger herumreichen. So ist es bei Java nicht möglich eine Methode als Argument zu übergeben (~foo(obj.method)~).
Der Workaround für dieses Problem ist dann oft, dass man eine Klasse ohne Attribute erzeugt, die genau eine Methode beinhaltet. Um jetzt diese Methode herum zu reichen, erzeugt man ein Objekt für die Klasse und reicht dieses herum. Auf diese Weise kann man den selben Effekt erreichen, als hätte man Funktionszeiger, da das Objekt ja die gebundene Methode Huckepack herumreicht. Allerdings, und da liegt das wirkliche Problem: Der Aufrufende muss den Methodennamen statisch kennen. In Java ist es (jedenfalls bevor es Lambdas gab) nicht möglich, anonyme Funktionsobjekte herumzureichen.
Um dieses Problem zu Umschiffen, gibt es sogar mehrere Designpatterns (Command, Strategy, Proxy), die als Surrogat für Funktionszeiger verwendet werden.


Das dritte Problem von (klassenbasierter) Objektorientierung ist die Illusion, dass es von jedem Objekttyp beliebig viele Instanzen geben kann. Allerdings gibt es manche Instanzen auf der Welt, von der es genau eins gibt, und von der auch nicht aus Versehen ein Zweites erzeugt werden sollte. Beispiele dafür sind Managerobjekte, die globale Daten verwalten. Ein solches Beispiel ist die Verwaltung der globalen Konfiguration des Programms. Es wäre wirklich schlecht, wenn es zwei konkurrierende globale Konfigurationsobjekte innerhalb eines Programms geben würde. Um dieses Problem zu umgehen, wurde das **Singleton**-Designpattern erfunden, das sicherstellt, dass eine Klasse nur genau einmal instantiiert wird. Wieder ein Entwurfsmuster, dass die Prinzipien von Objektorientierung gegen den Strich bürstet, weil die wahren Anforderungen doch nicht ganz in das Muster passen. Wieder ist beim Singleton der Umweg über statische Attribute und Methoden erforderlich (scheinbar ein ganz guter Indikator dafür, wenn etwas nicht ganz ins OO Schema passt).

Direkt angedockt an das Problem der singulären Instantiierung ist das Problem des **globalen Kontextes**. In reiner Objektorientierung kann es keine globale Variable geben, denn an welchem Objekt sollte dieses Variable denn als Attribut hängen. Das heißt, dass wir keinerlei Möglichkeit haben, globale Variablen als Seitenkanal für Konfigurationsflags zu verwenden. Eine Möglichkeit dies zu "beheben" ist, dass man ein generisches ~ProgramContext~-Objekt überall als Parameter durchschleift. Dies ist allerdings wirklich kein schönes Muster und zudem nicht komponierbar. Was würden wir machen, wenn unser Hauptprogramm einen ~ProgramContext~ durch eine Bibliothek, die keine Ahnung von dieser Klasse hat, durchschleifen wollen würde? Geht nicht. Der einzige Ausweg sind wieder, Sie ahnen es, Designpatterns. In diesem Fall Registry und ServiceLocator, beides selbst wiederum Singletons.

Der dritte Kritikpunkt an Objektorientierung ist seine Ineffizienz.
Wo die prozedurale Abstraktion kein Problem damit hat, innerhalb einer Prozedur eine Vielzahl von Objekten zu verarbeiten (rechte Seite auf der Folie), wäre man bei objektorientiertem Design dazu angehalten, die Funktionalität auf viele Methoden aufzuteilen. Dies geschieht dabei im vorauseilendem Gehorsam, denn irgendwann könnte irgendjemand mal auf die Idee kommen, für eine der Klassen die Methode in einer Unterklasse zu überschreiben. Den Preis für diese Flexibilität zahlen wir allerdings die ganze Zeit bis dahin: Zum einen wird der Code, durch die Aufteilung auf viele Methoden, schwerer überschaubar, und zum anderen zahlen wir Laufzeitkosten für die beständigen virtuellen Methodenaufrufe. Auch das implizite Durchschleifen des ~this~-Zeigers ist, obwohl es auf Ebene des Quellcodes unsichtbar ist, nicht umsonst. Und man zahlt die Kosten bei jedem Methodenaufruf.

In der nächsten Vorlesung schauen wir uns dann das funktionale Paradigma an, bei dem wir wirklich nur die Banane bekommen, und nicht immer gleich den ganzen Dschungel mitnehmen müssen.

* Zusammenfassung

#+begin_src latex
  \begin{frame}{Zusammenfassung}
    \bi
    \ii Programmierparadigmen sind Sammlungen von Sprachkonzepten {
      \bi
      \ii Ausweiten der semantischen Lücke macht eine Sprache \alert{nicht mächtiger},\\
          aber den Code besser \advantage{verständlich}.
      \ii Paradigmen werden durch Software-Engineering-Prinzipien diszipliniert.
      \ei
    }
    \ii Das imperative Programmierparadigma {
      \bi
      \ii Sequentielles Abarbeiten von Operationen, die den Zustand verändern
      \ii Strikte Vorgabe, wie eine Aufgabe durch zu führen ist
      \ii Prozedurale Abstraktion zerlegt das Problem entlang von Aufgaben
      \ei
    }
    \ii Das objektorientierte Programmierparadigma {
      \bi
      \ii \structure{Interagierende Objekte} sollen die reale Welt abbilden
      \ii Objekte senden \structure{Nachrichten} bzw. rufen sich ihre Methoden gegenseitig auf
      \ii Prototypen erlauben \structure{klassenlose Objektorientierung}
      \ei
    }
    \ii Objektorientierung hat ebenfalls \alert{Probleme} {
      \bi
      \ii Funktionen werden immer von Objekten dominiert.
      \ii Globaler Kontext nur über statische Methoden/Attribute
      \ii Designpatterns müssen konzeptionelle Schwächen ausgleichen.
      \ei
    }
    \ei
  
  \end{frame}
#+end_src

